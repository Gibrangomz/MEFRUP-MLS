# -*- coding: utf-8 -*-
# Requisitos:
#   pip install customtkinter pillow tkcalendar pandas matplotlib seaborn
import customtkinter as ctk
import tkinter as tk
from tkinter import messagebox, ttk
from PIL import Image
from tkcalendar import Calendar
import csv, os, logging, traceback
from datetime import datetime, date, timedelta

# === NUEVO: libs para reportes/gráficas
import pandas as pd
import matplotlib
matplotlib.use("Agg")  # backend offscreen para generar figuras y luego embederlas
import matplotlib.pyplot as plt
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
import seaborn as sns

# ---------- rutas / const ----------
BASE_DIR    = os.path.dirname(os.path.abspath(__file__))

# CSVs por máquina
MACHINES = [
    {
        "id": "arburg",
        "name": "ARBURG 320C GOLDEN EDITION",
        "oee_csv":  os.path.join(BASE_DIR, "oee_arburg.csv"),
        "down_csv": os.path.join(BASE_DIR, "down_arburg.csv")
    },
    {
        "id": "yizumi",
        "name": "YIZUMI UN90 A5",
        "oee_csv":  os.path.join(BASE_DIR, "oee_yizumi.csv"),
        "down_csv": os.path.join(BASE_DIR, "down_yizumi.csv")
    }
]

# diarios (compat) + combinado
DAILY_CSV_GLOBAL   = os.path.join(BASE_DIR, "oee_daily.csv")
DAILY_CSV_INJECTOR = os.path.join(BASE_DIR, "oee_inyeccion_daily.csv")

RECIPES_CSV = os.path.join(BASE_DIR, "recipes.csv")
LOGO_PATH   = os.path.join(BASE_DIR, "10b41fef-97af-4e79-90c4-b496e0dd3197.png")

# planificación y milestones
PLANNING_CSV = os.path.join(BASE_DIR, "planning.csv")   # orden, parte, molde_id, maquina_id, qty_total, inicio_ts, fin_est_ts, setup_min, estado, ciclo_s, cav_on
DELIV_CSV    = os.path.join(BASE_DIR, "deliveries.csv") # orden, due_date, qty, cumplido(0/1)

# NUEVO: salidas / embarques
SHIPMENTS_CSV = os.path.join(BASE_DIR, "shipments.csv") # orden, ship_date, qty, destino, nota

OPERADORES   = ["OPERADOR 1", "OPERADOR 2", "OPERADOR 3"]
TURNOS_HORAS = {1: 8, 2: 8, 3: 8}
DIAS_ES      = ["Lunes","Martes","Miércoles","Jueves","Viernes","Sábado","Domingo"]

TICK_MS     = 1000
DEBOUNCE_MS = 160
DASH_REFRESH_MS = 5000

MOTIVOS_PARO = [
    "Cambio de molde",
    "Pieza Atorada",
    "Sin operador",
    "Calidad",
    "Mantenimiento",
    "Energía (Se fue la luz)"
]

# ---------- CSV utils ----------
def asegurar_csv(path, header):
    try:
        with open(path, "x", newline="", encoding="utf-8") as f:
            csv.writer(f).writerow(header)
    except FileExistsError:
        pass

def leer_csv_dict(path):
    if not os.path.exists(path): return []
    with open(path, "r", newline="", encoding="utf-8") as f:
        return list(csv.DictReader(f))

def escribir_daily(path, fecha_iso, oee_pct, total, scrap, meta):
    asegurar_csv(path, ["fecha","oee_dia_%","total_pzs","scrap_pzs","meta_pzs"])
    rows = leer_csv_dict(path)
    for r in rows:
        if r.get("fecha")==fecha_iso:
            r["oee_dia_%"]=f"{oee_pct:.2f}"; r["total_pzs"]=str(total)
            r["scrap_pzs"]=str(scrap); r["meta_pzs"]=str(meta); break
    else:
        rows.append({"fecha":fecha_iso,"oee_dia_%":f"{oee_pct:.2f}",
                     "total_pzs":str(total),"scrap_pzs":str(scrap),"meta_pzs":str(meta)})
    with open(path,"w",newline="",encoding="utf-8") as f:
        w=csv.DictWriter(f,fieldnames=["fecha","oee_dia_%","total_pzs","scrap_pzs","meta_pzs"])
        w.writeheader(); w.writerows(rows)

def fechas_registradas(path_daily):
    asegurar_csv(path_daily, ["fecha","oee_dia_%","total_pzs","scrap_pzs","meta_pzs"])
    return {r["fecha"] for r in leer_csv_dict(path_daily) if r.get("fecha")}

def asegurar_archivos_basicos():
    asegurar_csv(DAILY_CSV_GLOBAL, ["fecha","oee_dia_%","total_pzs","scrap_pzs","meta_pzs"])
    asegurar_csv(DAILY_CSV_INJECTOR, ["fecha","oee_dia_%","total_pzs","scrap_pzs","meta_pzs"])
    asegurar_csv(RECIPES_CSV, [
        "molde_id","parte","ciclo_ideal_s","cavidades","cavidades_habilitadas","scrap_esperado_pct","activo"
    ])
    if not leer_csv_dict(RECIPES_CSV):
        with open(RECIPES_CSV,"a",newline="",encoding="utf-8") as f:
            w=csv.writer(f)
            w.writerow(["48","19-001-049","45","1","1","2","1"])
            w.writerow(["84","19-001-084","23","1","1","2","1"])
    asegurar_csv(PLANNING_CSV, ["orden","parte","molde_id","maquina_id","qty_total","inicio_ts","fin_est_ts","setup_min","estado","ciclo_s","cav_on"])
    asegurar_csv(DELIV_CSV,    ["orden","due_date","qty","cumplido"])
    asegurar_csv(SHIPMENTS_CSV,["orden","ship_date","qty","destino","nota"])

def asegurar_archivos_maquina(machine):
    asegurar_csv(machine["oee_csv"], [
        "timestamp","fecha","operador","turno","molde","parte","ciclo_s","horas_turno",
        "tiempo_paro_min","meta_oper_pzs","total_pzs","scrap_pzs","buenas_pzs",
        "availability_%","performance_%","quality_%","oee_%"
    ])
    asegurar_csv(machine["down_csv"], [
        "fecha","inicio_ts","fin_ts","duracion_seg","motivo","nota","operador","turno","molde"
    ])

# ---------- cálculos ----------
def calcular_tiempos(horas_turno, ciclo_s, paro_seg):
    turno_seg = int(max(0, horas_turno or 0) * 3600)
    operativo = max(0, turno_seg - int(max(0, paro_seg or 0)))
    ciclo     = int(ciclo_s or 0)
    meta_plan = int(turno_seg // ciclo) if ciclo>0 else 0
    meta_oper = int(operativo // ciclo) if ciclo>0 else 0
    return turno_seg, operativo, meta_plan, meta_oper

def calcular_metricas(total, scrap, turno_seg, oper_seg, ciclo_ideal_s):
    total   = int(total or 0)
    scrap   = int(scrap or 0)
    buenas  = max(0, total - scrap)
    A = (oper_seg/turno_seg) if turno_seg>0 else 0.0
    A = max(0.0, min(1.0, A))
    perf_num = buenas * float(ciclo_ideal_s or 0)
    P = (perf_num/oper_seg) if oper_seg>0 else 0.0
    P = max(0.0, min(1.0, P))
    Q = (buenas/total) if total>0 else 0.0
    OEE = A * P * Q * 100.0
    return buenas, round(A*100,2), round(P*100,2), round(Q*100,2), round(OEE,2)

def parse_int_str(s, default=0):
    try:
        s = str(s).replace(",",".").strip()
        return int(float(s))
    except:
        return default

def acum_por_fecha(rows, fecha_iso):
    total=scrap=0; meta=0.0; n=0; turno_seg=0; paro_seg=0
    for r in rows:
        if r.get("fecha")!=fecha_iso: continue
        try:
            total+=int(float(r.get("total_pzs","0")))
            scrap+=int(float(r.get("scrap_pzs","0")))
            meta +=float(r.get("meta_oper_pzs","0"))
            horas=float(str(r.get("horas_turno","0")).replace(",",".")) or 0.0
            turno_seg += int(horas*3600)
            pmin=float(str(r.get("tiempo_paro_min","0")).replace(",",".")) or 0.0
            paro_seg  += int(pmin*60)
            n+=1
        except: pass
    buenas=max(0,total-scrap)
    oper_seg=max(0, turno_seg-paro_seg)
    if total<=0 or meta<=0 or turno_seg<=0 or oper_seg<=0:
        return {"count":n,"total":total,"scrap":scrap,"buenas":buenas,
                "avail_pct":0.0,"perf_pct":0.0,"qual_pct":0.0,"oee_pct":0.0,"meta_pzs":meta}
    A=oper_seg/turno_seg
    P=total/meta
    Q=buenas/total
    OEE=A*P*Q*100.0
    return {"count":n,"total":total,"scrap":scrap,"buenas":buenas,
            "avail_pct":round(A*100,2),"perf_pct":round(P*100,2),"qual_pct":round(Q*100,2),
            "oee_pct":round(OEE,2),"meta_pzs":meta}

def acum_global(rows):
    total=scrap=0; meta=0.0; n=0; dias=set(); turno_seg=0; paro_seg=0
    for r in rows:
        try:
            total+=int(float(r.get("total_pzs","0")))
            scrap+=int(float(r.get("scrap_pzs","0")))
            meta +=float(r.get("meta_oper_pzs","0"))
            horas=float(str(r.get("horas_turno","0")).replace(",",".")) or 0.0
            turno_seg += int(horas*3600)
            pmin=float(str(r.get("tiempo_paro_min","0")).replace(",",".")) or 0.0
            paro_seg  += int(pmin*60)
            n+=1
            if r.get("fecha"): dias.add(r["fecha"])
        except: pass
    buenas=max(0,total-scrap)
    oper_seg=max(0, turno_seg-paro_seg)
    if total<=0 or meta<=0 or turno_seg<=0 or oper_seg<=0:
        return {"registros":n,"dias":len(dias),"total":total,"scrap":scrap,
                "buenas":buenas,"avail_pct":0.0,"perf_pct":0.0,
                "qual_pct":0.0,"oee_pct":0.0,"meta_pzs":meta}
    A=oper_seg/turno_seg
    P=total/meta
    Q=buenas/total
    OEE=A*P*Q*100.0
    return {"registros":n,"dias":len(dias),"total":total,"scrap":scrap,"buenas":buenas,
            "avail_pct":round(A*100,2),"perf_pct":round(P*100,2),
            "qual_pct":round(Q*100,2),"oee_pct":round(OEE,2),"meta_pzs":meta}

def promedio_oee_daily(path_daily):
    vals=[float(r.get("oee_dia_%","0") or 0) for r in leer_csv_dict(path_daily)] if os.path.exists(path_daily) else []
    return round(sum(vals)/len(vals),2) if vals else 0.0

def dia_semana_es(f):
    try: y,m,d=map(int,f.split("-")); return DIAS_ES[date(y,m,d).weekday()]
    except: return "Día"

def segs_to_hms_str(s):
    s=max(0,int(s)); h=s//3600; m=(s%3600)//60; sc=s%60; return f"{h:02d}:{m:02d}:{sc:02d}"

# ===== producidas por molde (para milestones/órdenes) =====
def producido_por_molde_global(molde_id: str, hasta_fecha: str = None) -> int:
    total_buenas = 0
    for m in MACHINES:
        rows = leer_csv_dict(m["oee_csv"])
        for r in rows:
            try:
                if str(r.get("molde","")).strip() == str(molde_id).strip():
                    if hasta_fecha:
                        if (r.get("fecha") or "") <= hasta_fecha:
                            total_buenas += int(float(r.get("buenas_pzs","0")))
                    else:
                        total_buenas += int(float(r.get("buenas_pzs","0")))
            except: pass
    return total_buenas

def enviados_por_orden(orden: str) -> int:
    return sum(parse_int_str(r.get("qty","0")) for r in leer_csv_dict(SHIPMENTS_CSV) if r.get("orden")==orden)

# ===== resumen por máquina (hoy) con fallback robusto =====
def _safe_float(x, default=0.0):
    try: return float(str(x).replace(",",".")) if x not in (None,"") else default
    except: return default

def resumen_hoy_maquina(machine, fecha_iso):
    asegurar_archivos_maquina(machine)
    rows = [r for r in leer_csv_dict(machine["oee_csv"]) if r.get("fecha")==fecha_iso]
    if not rows:
        return dict(oee=0.0,A=0.0,P=0.0,Q=0.0,total=0,buenas=0,scrap=0,
                    meta=0, ciclo_ideal=0, ciclo_real=0.0,
                    turno_seg=0, oper_seg=0, ultimo_paro="-", oee_dia=0.0)
    total = sum(parse_int_str(r.get("total_pzs","0")) for r in rows)
    scrap = sum(parse_int_str(r.get("scrap_pzs","0")) for r in rows)
    buenas= max(0,total-scrap)
    horas_sum = sum(_safe_float(r.get("horas_turno","0")) for r in rows)
    turno_seg = int(horas_sum * 3600)
    paro_seg  = int(sum(_safe_float(r.get("tiempo_paro_min","0")) for r in rows) * 60)
    oper_seg  = max(0, turno_seg - paro_seg)
    ciclos = [parse_int_str(r.get("ciclo_s","0")) for r in rows if parse_int_str(r.get("ciclo_s","0"))>0]
    ciclo_ideal = ciclos[-1] if ciclos else 0
    if turno_seg>0 and ciclo_ideal>0:
        A = (oper_seg/turno_seg); P = ((buenas*ciclo_ideal)/oper_seg) if oper_seg>0 else 0.0; Q = (buenas/total) if total>0 else 0.0
        oee = A*P*Q*100.0; A*=100.0; P*=100.0; Q*=100.0
    else:
        A = sum(_safe_float(r.get("availability_%","0")) for r in rows) / max(1,len(rows))
        P = sum(_safe_float(r.get("performance_%","0")) for r in rows) / max(1,len(rows))
        Q = sum(_safe_float(r.get("quality_%","0")) for r in rows) / max(1,len(rows))
        oee = sum(_safe_float(r.get("oee_%","0")) for r in rows) / max(1,len(rows))
    meta_oper = int((oper_seg // ciclo_ideal) if ciclo_ideal>0 else 0)
    ciclo_real = (oper_seg/buenas) if buenas>0 else 0.0
    downs = [r for r in leer_csv_dict(machine["down_csv"]) if r.get("fecha")==fecha_iso]
    if downs:
        d = downs[-1]
        try:
            mins = round(int(float(d.get("duracion_seg","0")))/60.0,1)
            ultimo = f"{d.get('inicio_ts','')} -> {d.get('fin_ts','')}   {mins:.1f} min ({d.get('motivo','')})"
        except:
            ultimo = f"{d.get('inicio_ts','')} -> {d.get('fin_ts','')}   ({d.get('motivo','')})"
    else:
        ultimo="-"
    # === NUEVO: OEE acumulado del día (misma fuente que el área)
    a = acum_por_fecha(leer_csv_dict(machine["oee_csv"]), fecha_iso)
    oee_dia = a["oee_pct"]
    return dict(oee=round(oee,2),A=round(A,2),P=round(P,2),Q=round(Q,2),
                total=total,buenas=buenas,scrap=scrap, meta=meta_oper,
                ciclo_ideal=ciclo_ideal, ciclo_real=round(ciclo_real,2),
                turno_seg=turno_seg, oper_seg=oper_seg, ultimo_paro=ultimo,
                oee_dia=round(oee_dia,2))

# ---------- Vistas ----------
class RecipesView(ctk.CTkFrame):
    """Gestor de Recetas (molde/parte/ciclo...)"""
    def __init__(self, master, app):
        super().__init__(master, fg_color="transparent")
        self.app=app
        self._build()
    def _build(self):
        header=ctk.CTkFrame(self, corner_radius=0, fg_color=("white","#111111"))
        header.pack(fill="x", side="top")
        left=ctk.CTkFrame(header, fg_color="transparent"); left.pack(side="left", padx=16, pady=10)
        ctk.CTkButton(left, text="← Menú", command=self.app.go_menu, width=100, corner_radius=10,
                      fg_color="#E5E7EB", text_color="#111", hover_color="#D1D5DB").pack(side="left", padx=(0,10))
        ctk.CTkLabel(left, text="Recetas — Moldes/Partes", font=ctk.CTkFont("Helvetica", 20, "bold")).pack(side="left")
        body=ctk.CTkFrame(self, fg_color="transparent"); body.pack(fill="both", expand=True, padx=16, pady=16)
        table_card=ctk.CTkFrame(body, corner_radius=18); table_card.pack(side="left", fill="both", expand=True, padx=(0,10))
        ctk.CTkLabel(table_card, text="Recetas", font=ctk.CTkFont("Helvetica",13,"bold")).pack(anchor="w", padx=8, pady=(8,0))
        ctk.CTkFrame(table_card, height=1, fg_color=("#E5E7EB","#2B2B2B")).pack(fill="x", padx=8, pady=(6,8))
        cols=("molde_id","parte","ciclo_ideal_s","cavidades","cavidades_habilitadas","scrap_esperado_pct","activo")
        self.tree=ttk.Treeview(table_card, columns=cols, show="headings", height=12)
        heads=[("molde_id","Molde",90),("parte","# Parte",140),("ciclo_ideal_s","Ciclo (s)",90),
               ("cavidades","Cav.",70),("cavidades_habilitadas","Cav. ON",80),
               ("scrap_esperado_pct","Scrap %",80),("activo","Activo",70)]
        for key,txt,w in heads:
            self.tree.heading(key, text=txt); self.tree.column(key, width=w, anchor="center")
        self.tree.pack(fill="both", expand=True, padx=8, pady=(0,8))
        self.tree.bind("<<TreeviewSelect>>", self._on_select)
        btnbar=ctk.CTkFrame(table_card, fg_color="transparent"); btnbar.pack(fill="x", padx=8, pady=(0,10))
        ctk.CTkButton(btnbar, text="Nuevo", command=self._new).pack(side="left", padx=(0,8))
        ctk.CTkButton(btnbar, text="Guardar", command=self._save).pack(side="left", padx=8)
        ctk.CTkButton(btnbar, text="Eliminar", fg_color="#ef4444", hover_color="#dc2626", command=self._delete).pack(side="left", padx=8)
        ctk.CTkButton(btnbar, text="↻ Recargar", fg_color="#E5E7EB", text_color="#111", hover_color="#D1D5DB", command=self._load).pack(side="left", padx=8)
        ctk.CTkButton(btnbar, text="Ir a OEE", command=self.app.go_oee_select_machine).pack(side="right")
        form=ctk.CTkFrame(body, corner_radius=18); form.pack(side="left", fill="both", expand=False, padx=(10,0))
        ctk.CTkLabel(form, text="Editar receta", font=ctk.CTkFont("Helvetica",13,"bold")).pack(anchor="w", padx=8, pady=(8,0))
        ctk.CTkFrame(form, height=1, fg_color=("#E5E7EB","#2B2B2B")).pack(fill="x", padx=8, pady=(6,8))
        def frow(lbl, var, width=160, typ="entry"):
            r=ctk.CTkFrame(form, fg_color="transparent"); r.pack(fill="x", padx=8, pady=4)
            ctk.CTkLabel(r, text=lbl).pack(side="left")
            if typ=="entry":
                e=ctk.CTkEntry(r, width=width, textvariable=var, justify="center"); e.pack(side="right"); return e
            else:
                om=ctk.CTkOptionMenu(r, values=["0","1"], variable=var); om.pack(side="right"); return om
        self.var_molde = tk.StringVar()           # <<< mantener como string para no romper IDs alfanuméricos
        self.var_parte = tk.StringVar()
        self.var_ciclo = tk.StringVar()
        self.var_cavs  = tk.StringVar()
        self.var_cavs_on = tk.StringVar()
        self.var_scrap = tk.StringVar()
        self.var_activo= tk.StringVar(value="1")
        frow("Molde ID", self.var_molde)
        frow("# Parte", self.var_parte)
        frow("Ciclo ideal (s)", self.var_ciclo)
        frow("Cavidades", self.var_cavs)
        frow("Cavidades habilitadas", self.var_cavs_on)
        frow("Scrap esperado (%)", self.var_scrap)
        frow("Activo (1/0)", self.var_activo, typ="om")
        self._load()
    def _load(self):
        for i in self.tree.get_children(): self.tree.delete(i)
        for r in leer_csv_dict(RECIPES_CSV):
            self.tree.insert("", "end", values=(r["molde_id"], r["parte"], r["ciclo_ideal_s"],
                                                r["cavidades"], r["cavidades_habilitadas"],
                                                r["scrap_esperado_pct"], r["activo"]))
        self.app._refresh_moldes_from_recipes()
    def _on_select(self, *_):
        sel=self.tree.selection()
        if not sel: return
        vals=self.tree.item(sel[0],"values")
        (self.var_molde.set(vals[0]), self.var_parte.set(vals[1]), self.var_ciclo.set(vals[2]),
         self.var_cavs.set(vals[3]), self.var_cavs_on.set(vals[4]), self.var_scrap.set(vals[5]),
         self.var_activo.set(vals[6]))
    def _new(self):
        self.var_molde.set(""); self.var_parte.set(""); self.var_ciclo.set("")
        self.var_cavs.set(""); self.var_cavs_on.set(""); self.var_scrap.set(""); self.var_activo.set("1")
    def _save(self):
        m=self.var_molde.get().strip()
        if not (m and self.var_ciclo.get().strip()):
            messagebox.showwarning("Faltan datos","Molde y ciclo ideal son obligatorios."); return
        rows=leer_csv_dict(RECIPES_CSV); found=False
        for r in rows:
            if r["molde_id"]==m:
                r.update({
                    "parte": self.var_parte.get().strip(),
                    "ciclo_ideal_s": self.var_ciclo.get().strip(),
                    "cavidades": self.var_cavs.get().strip(),
                    "cavidades_habilitadas": self.var_cavs_on.get().strip(),
                    "scrap_esperado_pct": self.var_scrap.get().strip(),
                    "activo": self.var_activo.get().strip() or "1"
                })
                found=True; break
        if not found:
            rows.append({
                "molde_id": m,
                "parte": self.var_parte.get().strip(),
                "ciclo_ideal_s": self.var_ciclo.get().strip(),
                "cavidades": self.var_cavs.get().strip(),
                "cavidades_habilitadas": self.var_cavs_on.get().strip(),
                "scrap_esperado_pct": self.var_scrap.get().strip(),
                "activo": self.var_activo.get().strip() or "1"
            })
        with open(RECIPES_CSV,"w",newline="",encoding="utf-8") as f:
            w=csv.DictWriter(f, fieldnames=["molde_id","parte","ciclo_ideal_s",
                                            "cavidades","cavidades_habilitadas","scrap_esperado_pct","activo"])
            w.writeheader(); w.writerows(rows)
        self._load(); messagebox.showinfo("Recetas","Receta guardada.")
        self.app._refresh_moldes_from_recipes()
        try:
            self.app._on_molde_change(); self.app._update_now()
        except: pass
    def _delete(self):
        sel=self.tree.selection()
        if not sel: return
        molde = self.tree.item(sel[0],"values")[0]
        if not messagebox.askyesno("Eliminar","¿Eliminar la receta del molde "+str(molde)+"?"): return
        rows=[r for r in leer_csv_dict(RECIPES_CSV) if r["molde_id"]!=molde]
        with open(RECIPES_CSV,"w",newline="",encoding="utf-8") as f:
            w=csv.DictWriter(f, fieldnames=["molde_id","parte","ciclo_ideal_s",
                                            "cavidades","cavidades_habilitadas","scrap_esperado_pct","activo"])
            w.writeheader(); w.writerows(rows)
        self._load(); self.app._refresh_moldes_from_recipes()
        try:
            self.app._on_molde_change(); self.app._update_now()
        except: pass

class MachineChooser(ctk.CTkFrame):
    def __init__(self, master, app):
        super().__init__(master, fg_color="transparent")
        self.app=app
        box=ctk.CTkFrame(self, corner_radius=20); box.pack(expand=True, fill="both", padx=40, pady=40)
        ctk.CTkLabel(box, text="Selecciona máquina", font=ctk.CTkFont("Helvetica",26,"bold")).pack(pady=(18,8))
        grid=ctk.CTkFrame(box, fg_color="transparent"); grid.pack(pady=10)
        for i, m in enumerate(MACHINES):
            ctk.CTkButton(grid, text=m["name"], height=56, corner_radius=16,
                          command=lambda mm=m: self.app.go_oee(mm)).grid(row=i, column=0, pady=8, padx=8, sticky="ew")
        ctk.CTkButton(box, text="← Volver al menú", height=44, corner_radius=12,
                      fg_color="#E5E7EB", text_color="#111", hover_color="#D1D5DB",
                      command=self.app.go_menu).pack(pady=(18,0))

class OEEView(ctk.CTkFrame):
    def __init__(self, master, app, machine):
        super().__init__(master, fg_color="transparent")
        self.app=app; self.machine=machine
        self._build_header(); self._build_body()
    def _build_header(self):
        header=ctk.CTkFrame(self, corner_radius=0, fg_color=("white","#111111")); header.pack(fill="x", side="top")
        left=ctk.CTkFrame(header, fg_color="transparent"); left.pack(side="left", padx=16, pady=10)
        ctk.CTkButton(left, text="← Elegir máquina", command=self.app.go_oee_select_machine, width=140, corner_radius=10,
                      fg_color="#E5E7EB", text_color="#111", hover_color="#D1D5DB").pack(side="left", padx=(0,10))
        ctk.CTkLabel(left, text=f"OEE — Registro de Producción ({self.machine['name']})",
                     font=ctk.CTkFont("Helvetica", 20, "bold")).pack(side="left")
        right=ctk.CTkFrame(header, fg_color="transparent"); right.pack(side="right", padx=16, pady=10)
        self.clock_lbl = ctk.CTkLabel(right, text="", font=ctk.CTkFont("Helvetica",13)); self.clock_lbl.pack(side="right", padx=(8,0))
        theme = ctk.CTkSegmentedButton(right, values=["Claro","Oscuro"],
                                       command=lambda v: ctk.set_appearance_mode("dark" if v=="Oscuro" else "light"))
        theme.set("Claro"); theme.pack(side="right", padx=10)
        try:
            img=Image.open(LOGO_PATH); logo=ctk.CTkImage(light_image=img, dark_image=img, size=(120,48))
            ctk.CTkLabel(right, image=logo, text="").pack(side="right", padx=10); self.logo=logo
        except: pass
    def _build_body(self):
        body=ctk.CTkFrame(self, fg_color="transparent"); body.pack(fill="both", expand=True, padx=16, pady=16)
        body.grid_rowconfigure(0, weight=1); body.grid_columnconfigure(0, weight=1); body.grid_columnconfigure(1, weight=1)
        # izquierda
        left=ctk.CTkScrollableFrame(body, corner_radius=18); left.grid(row=0, column=0, sticky="nsew", padx=(0,10))
        # Fecha
        sec=self._sec(left,"Fecha"); sec.pack(fill="x", padx=14, pady=(14,8))
        row=ctk.CTkFrame(sec, fg_color="transparent"); row.pack(fill="x")
        ctk.CTkLabel(row, text="YYYY-MM-DD").pack(side="left")
        ctk.CTkEntry(row, width=140, textvariable=self.app.fecha_sel, justify="center").pack(side="left", padx=8)
        ctk.CTkButton(row, text="Usar", command=self.app._on_fecha_change).pack(side="left", padx=8)
        ctk.CTkButton(row, text="📅", width=40, command=self.app._open_calendar).pack(side="left", padx=6)
        self.lbl_dia=ctk.CTkLabel(sec, text="", font=ctk.CTkFont("Helvetica", 12, "bold")); self.lbl_dia.pack(anchor="w", pady=(6,0))
        self.app.lbl_dia=self.lbl_dia
        # Operador
        sec=self._sec(left,"Operador"); sec.pack(fill="x", padx=14, pady=8)
        op=ctk.CTkOptionMenu(sec, values=["Selecciona"]+[o.capitalize() for o in OPERADORES],
                             command=lambda v: self.app._set_operador(v.lower()) if v!="Selecciona" else None)
        op.set("Selecciona"); op.pack(fill="x", padx=4, pady=4)
        # Turno
        sec=self._sec(left,"Turno"); sec.pack(fill="x", padx=14, pady=8)
        tu=ctk.CTkOptionMenu(sec, values=["Selecciona","1","2","3"],
                             command=lambda v: self.app._set_turno(v) if v.isdigit() else None)
        tu.set("Selecciona"); tu.pack(fill="x", padx=4, pady=4)
        # Molde / Receta
        sec=self._sec(left,"Molde / Receta"); sec.pack(fill="x", padx=14, pady=8)
        valores_moldes = ["Selecciona"] + sorted([k for k in self.app.recipe_map.keys()])
        self.molde_menu = ctk.CTkOptionMenu(sec, values=valores_moldes, command=self.app._set_molde)
        self.molde_menu.pack(fill="x", padx=4, pady=4)
        info = ctk.CTkFrame(sec, fg_color="transparent"); info.pack(fill="x", pady=(6,0))
        ctk.CTkLabel(info, text="Ciclo ideal (s):").grid(row=0, column=0, sticky="w", padx=(0,6))
        ctk.CTkLabel(info, textvariable=self.app.ciclo_s, font=ctk.CTkFont("Helvetica",12,"bold")).grid(row=0, column=1, sticky="w")
        ctk.CTkLabel(info, text="# Parte:").grid(row=1, column=0, sticky="w", padx=(0,6), pady=(4,0))
        self.lbl_parte = ctk.CTkLabel(info, text="", font=ctk.CTkFont("Helvetica",12,"bold")); self.lbl_parte.grid(row=1, column=1, sticky="w", pady=(4,0))
        ctk.CTkLabel(info, text="Cavidades (ON/Tot):").grid(row=2, column=0, sticky="w", padx=(0,6), pady=(4,0))
        self.lbl_cavs = ctk.CTkLabel(info, text="", font=ctk.CTkFont("Helvetica",12,"bold")); self.lbl_cavs.grid(row=2, column=1, sticky="w", pady=(4,0))
        self.app.lbl_parte = self.lbl_parte; self.app.lbl_cavs  = self.lbl_cavs
        # Producción
        sec=self._sec(left,"Producción (turno)"); sec.pack(fill="x", padx=14, pady=8)
        self._counter(sec,"Total",self.app.total); self._counter(sec,"Scrap",self.app.scrap)
        actions=ctk.CTkFrame(sec, fg_color="transparent"); actions.pack(fill="x", pady=(10,0))
        self.btn_guardar=ctk.CTkButton(actions, text="Guardar (Ctrl+Enter)", corner_radius=12, command=self.app._guardar)
        self.btn_guardar.pack(side="left", expand=True, fill="x", padx=(0,6))
        ctk.CTkButton(actions, text="Reset contadores", corner_radius=12, fg_color="#E5E7EB",
                      text_color="#111", hover_color="#D1D5DB", command=self.app._reset_contadores)\
            .pack(side="left", expand=True, fill="x", padx=(6,0))
        self.app.btn_guardar=self.btn_guardar
        # Paros
        sec=self._sec(left,"Paros (cronómetro)"); sec.pack(fill="x", padx=14, pady=8)
        picker=ctk.CTkFrame(sec, fg_color="transparent"); picker.pack(fill="x", pady=(0,8))
        ctk.CTkLabel(picker, text="Motivo").pack(side="left")
        self.motivo_menu = ctk.CTkOptionMenu(picker, values=MOTIVOS_PARO); self.motivo_menu.pack(side="left", padx=8)
        ctk.CTkLabel(picker, text="Nota").pack(side="left", padx=(12,0))
        self.nota_entry=ctk.CTkEntry(picker, width=220, placeholder_text="opcional"); self.nota_entry.pack(side="left", padx=8)
        r1=ctk.CTkFrame(sec, fg_color="transparent"); r1.pack(fill="x", pady=(2,2))
        ctk.CTkLabel(r1, text="Paro actual").pack(side="left")
        self.lbl_paro_actual=ctk.CTkLabel(r1, text="00:00:00", font=ctk.CTkFont("Helvetica",16,"bold")); self.lbl_paro_actual.pack(side="right")
        r2=ctk.CTkFrame(sec, fg_color="transparent"); r2.pack(fill="x", pady=(2,8))
        ctk.CTkLabel(r2, text="Paro acumulado (turno)").pack(side="left")
        self.lbl_paro_acum=ctk.CTkLabel(r2, text="00:00:00", font=ctk.CTkFont("Helvetica",16,"bold")); self.lbl_paro_acum.pack(side="right")
        rbtn=ctk.CTkFrame(sec, fg_color="transparent"); rbtn.pack(fill="x", pady=(0,8))
        self.btn_toggle_paro=ctk.CTkButton(rbtn, text="Iniciar paro", height=44, corner_radius=14,
                                           command=self.app.toggle_paro, fg_color="#ef4444", hover_color="#dc2626")
        self.btn_toggle_paro.pack(side="left", expand=True, fill="x", padx=(0,8))
        ctk.CTkButton(rbtn, text="Reset paros", height=44, corner_radius=14, fg_color="#E5E7EB",
                      text_color="#111", hover_color="#D1D5DB", command=self.app.reset_paros)\
            .pack(side="left", expand=True, fill="x", padx=(8,0))
        # bitácora
        table_card=ctk.CTkFrame(sec, corner_radius=10); table_card.pack(fill="both", expand=True, pady=(10,0))
        cols=("inicio","fin","motivo","nota","dur_min")
        self.tree=ttk.Treeview(table_card, columns=cols, show="headings", height=6)
        for c, txt, w, anchor in [("inicio","Inicio",135,"center"),("fin","Fin",135,"center"),
                                  ("motivo","Motivo",160,"w"),("nota","Nota",220,"w"),("dur_min","Dur (min)",80,"e")]:
            self.tree.heading(c, text=txt); self.tree.column(c, width=w, anchor=anchor)
        self.tree.pack(fill="both", expand=True, padx=8, pady=8)
        style=ttk.Style(); style.configure("Treeview", rowheight=24, font=("Helvetica",10))
        style.configure("Treeview.Heading", font=("Helvetica",10,"bold"))
        # derecha
        right=ctk.CTkFrame(body, corner_radius=18); right.grid(row=0, column=1, sticky="nsew", padx=(10,0))
        sec=self._sec(right,"Metas"); sec.pack(fill="x", padx=14, pady=(14,8))
        r=ctk.CTkFrame(sec, fg_color="transparent"); r.pack(fill="x")
        ctk.CTkLabel(r, text="Meta planificada (pzs)").pack(side="left")
        self.meta_plan_val=ctk.CTkLabel(r, text="0", font=ctk.CTkFont("Helvetica",16,"bold")); self.meta_plan_val.pack(side="left", padx=6)
        r=ctk.CTkFrame(sec, fg_color="transparent"); r.pack(fill="x", pady=(6,0))
        ctk.CTkLabel(r, text="Meta operativa (pzs)").pack(side="left")
        self.meta_oper_val=ctk.CTkLabel(r, text="0", font=ctk.CTkFont("Helvetica",16,"bold")); self.meta_oper_val.pack(side="left", padx=6)
        bars=ctk.CTkFrame(right, fg_color="transparent"); bars.pack(fill="x", padx=14, pady=8)
        ctk.CTkLabel(bars, text="Disponibilidad").pack(anchor="w")
        self.pb_avail=ctk.CTkProgressBar(bars); self.pb_avail.set(0.0); self.pb_avail.pack(fill="x", pady=(2,8))
        ctk.CTkLabel(bars, text="Avance a meta (operativa)").pack(anchor="w")
        self.pb_meta=ctk.CTkProgressBar(bars); self.pb_meta.set(0.0); self.pb_meta.pack(fill="x", pady=(2,8))
        ctk.CTkLabel(bars, text="Calidad (Buenas / Total)").pack(anchor="w")
        self.pb_quality=ctk.CTkProgressBar(bars); self.pb_quality.set(0.0); self.pb_quality.pack(fill="x", pady=(2,8))
        sec=self._sec(right,"Tiempo real (turno)"); sec.pack(fill="x", padx=14, pady=8)
        self._metric(sec,"Availability (RT)",self.app.avail_rt)
        self._metric(sec,"Performance (RT)",self.app.perf_rt)
        self._metric(sec,"Quality (RT)",self.app.qual_rt)
        self._metric(sec,"OEE (RT)",self.app.oee_rt)
        sec=self._sec(right,"Día seleccionado (acumulado)"); sec.pack(fill="x", padx=14, pady=8)
        self._metric(sec,"Total día",self.app.tot_day)
        self._metric(sec,"Scrap día",self.app.scr_day)
        self._metric(sec,"Buenas día",self.app.buen_day)
        self._metric(sec,"Performance día",self.app.perf_day)
        self._metric(sec,"Quality día",self.app.qual_day)
        self._metric(sec,"OEE día",self.app.oee_day)
        ctk.CTkLabel(sec, textvariable=self.app.day_info, text_color=("#6b7280","#9CA3AF")).pack(anchor="w", pady=(6,0))
        sec=self._sec(right,"Histórico (promedio OEE día)"); sec.pack(fill="x", padx=14, pady=8)
        self._metric(sec,"OEE histórico",self.app.oee_hist)
        sec=self._sec(right,"Global (todos los registros)"); sec.pack(fill="x", padx=14, pady=(8,14))
        self._metric(sec,"Total global",self.app.glob_total)
        self._metric(sec,"Scrap global",self.app.glob_scrap)
        self._metric(sec,"Buenas global",self.app.glob_buenas)
        self._metric(sec,"Performance global",self.app.glob_perf)
        self._metric(sec,"Quality global",self.app.glob_qual)
        self._metric(sec,"OEE global",self.app.glob_oee)
        ctk.CTkLabel(sec, textvariable=self.app.glob_info, text_color=("#6b7280","#9CA3AF")).pack(anchor="w", pady=(6,0))
        self.app.meta_plan_val=self.meta_plan_val; self.app.meta_oper_val=self.meta_oper_val
        self.app.pb_avail=self.pb_avail; self.app.pb_meta=self.pb_meta; self.app.pb_quality=self.pb_quality
        self.app.lbl_paro_actual=self.lbl_paro_actual; self.app.lbl_paro_acum=self.lbl_paro_acum
        self.app.btn_toggle_paro=self.btn_toggle_paro
        self.app.motivo_menu=self.motivo_menu; self.app.nota_entry=self.nota_entry; self.app.tree=self.tree
        self.app.molde_menu=self.molde_menu
        self.app._clock_label = self.clock_lbl
    # helpers UI
    def _sec(self, parent, title):
        card=ctk.CTkFrame(parent, corner_radius=16)
        ctk.CTkLabel(card, text=title, font=ctk.CTkFont("Helvetica",13,"bold")).pack(anchor="w", padx=8, pady=(8,0))
        ctk.CTkFrame(card, height=1, fg_color=("#E5E7EB","#2B2B2B")).pack(fill="x", padx=8, pady=(6,8))
        return card
    def _counter(self, parent, label, var):
        r=ctk.CTkFrame(parent, fg_color="transparent"); r.pack(fill="x", pady=6)
        ctk.CTkLabel(r, text=label).pack(side="left")
        e=ctk.CTkEntry(r, width=140, textvariable=var, justify="center"); e.pack(side="left", padx=8)
        ctk.CTkButton(r, text="-", width=44, height=40, command=lambda: self.app._nudge(var,-1), corner_radius=14).pack(side="left", padx=4)
        ctk.CTkButton(r, text="+", width=44, height=40, command=lambda: self.app._nudge(var,+1), corner_radius=14).pack(side="left", padx=4)
        e.bind("<FocusOut>", lambda ev: self.app._sanitize(var)); e.bind("<Return>", lambda ev: self.app._sanitize(var))
    def _metric(self, parent, label, var):
        r=ctk.CTkFrame(parent, fg_color="transparent"); r.pack(fill="x", pady=4)
        ctk.CTkLabel(r, text=label).pack(side="left")
        ctk.CTkLabel(r, textvariable=var, font=ctk.CTkFont("Helvetica",16,"bold")).pack(side="right")

# ===== TABLERO EN VIVO (mejorado) =====
class LiveDashboard(ctk.CTkFrame):
    def __init__(self, master, app):
        super().__init__(master, fg_color="transparent")
        self.app = app
        self._timer = None
        self._build()

    def _tone(self, oee):
        if oee >= 85: return ("#DCFCE7", "#065F46")
        if oee >= 60: return ("#FEF9C3", "#92400E")
        return ("#FEE2E2", "#991B1B")

    def _build(self):
        header = ctk.CTkFrame(self, corner_radius=0, fg_color=("white","#111111"))
        header.pack(fill="x", side="top")
        left = ctk.CTkFrame(header, fg_color="transparent"); left.pack(side="left", padx=16, pady=10)
        ctk.CTkButton(left, text="← Menú", command=self.app.go_menu, width=110, corner_radius=10,
                      fg_color="#E5E7EB", text_color="#111", hover_color="#D1D5DB").pack(side="left", padx=(0,10))
        ctk.CTkLabel(left, text="Tablero en vivo — Área de Inyección",
                     font=ctk.CTkFont("Helvetica", 20, "bold")).pack(side="left")

        right = ctk.CTkFrame(header, fg_color="transparent"); right.pack(side="right", padx=16, pady=10)
        self.clock_lbl = ctk.CTkLabel(right, text="", font=ctk.CTkFont("Helvetica",13))
        self.clock_lbl.pack(side="right", padx=(8,0))
        ctk.CTkButton(right, text="Actualizar", command=self._refresh_now, width=110)\
            .pack(side="right", padx=(0,8))
        try:
            img=Image.open(LOGO_PATH); logo=ctk.CTkImage(light_image=img, dark_image=img, size=(120,48))
            ctk.CTkLabel(right, image=logo, text="").pack(side="right", padx=10); self.logo=logo
        except: pass

        body = ctk.CTkFrame(self, fg_color="transparent"); body.pack(fill="both", expand=True, padx=16, pady=16)
        body.grid_columnconfigure(0, weight=1); body.grid_columnconfigure(1, weight=1); body.grid_rowconfigure(1, weight=1)

        # Top: OEE Área
        self.card_area = ctk.CTkFrame(body, corner_radius=18)
        self.card_area.grid(row=0, column=0, columnspan=2, sticky="ew", padx=6, pady=(0,12))
        ctk.CTkLabel(self.card_area, text="OEE Área (hoy)", font=ctk.CTkFont("Helvetica", 16, "bold"))\
            .pack(anchor="w", padx=12, pady=(10,0))
        self.lbl_area = ctk.CTkLabel(self.card_area, text="0.00 %", font=ctk.CTkFont("Helvetica", 28, "bold"))
        self.lbl_area.pack(anchor="w", padx=12, pady=(4,12))

        # Cards por máquina
        self.cards = {}
        for i, m in enumerate(MACHINES):
            card = ctk.CTkFrame(body, corner_radius=18)
            card.grid(row=1, column=i, sticky="nsew", padx=6, pady=6)
            ctk.CTkLabel(card, text=m["name"], font=ctk.CTkFont("Helvetica", 15, "bold"))\
                .pack(anchor="w", padx=12, pady=(10,6))
            row1 = ctk.CTkFrame(card, fg_color="transparent"); row1.pack(fill="x", padx=12)

            self.cards[m["id"]] = {
                "wrap": card,
                "oee": ctk.CTkLabel(row1, text="OEE (RT) 0.00%", font=ctk.CTkFont("Helvetica",16,"bold")),
                "A":   ctk.CTkLabel(row1, text="A 0.00%", font=ctk.CTkFont("Helvetica",13)),
                "P":   ctk.CTkLabel(row1, text="P 0.00%", font=ctk.CTkFont("Helvetica",13)),
                "Q":   ctk.CTkLabel(row1, text="Q 0.00%", font=ctk.CTkFont("Helvetica",13)),
                "dia": ctk.CTkLabel(card, text="OEE día: 0.00%", font=ctk.CTkFont("Helvetica",13))
            }
            self.cards[m["id"]]["oee"].pack(side="left")
            self.cards[m["id"]]["A"].pack(side="left", padx=(12,0))
            self.cards[m["id"]]["P"].pack(side="left", padx=(12,0))
            self.cards[m["id"]]["Q"].pack(side="left", padx=(12,0))
            self.cards[m["id"]]["dia"].pack(anchor="w", padx=12, pady=(6,0))
            self.cards[m["id"]]["paro"]= ctk.CTkLabel(card, text="Último paro: -", wraplength=520, justify="left")
            self.cards[m["id"]]["paro"].pack(anchor="w", padx=12, pady=(8,10))

        # Panel de gráficas
        charts = ctk.CTkFrame(self, corner_radius=18)
        charts.pack(fill="x", padx=16, pady=(0,16))
        ctk.CTkLabel(charts, text="Estadística rápida", font=ctk.CTkFont("Helvetica", 14, "bold"))\
            .pack(anchor="w", padx=12, pady=(10,6))
        self.chart_area_frame = ctk.CTkFrame(charts, corner_radius=12); self.chart_area_frame.pack(fill="x", padx=12, pady=(0,12))
        self.chart_today_frame= ctk.CTkFrame(charts, corner_radius=12); self.chart_today_frame.pack(fill="x", padx=12, pady=(0,12))

        self._refresh_now()

    def _last7_area(self):
        out=[]; today=date.today()
        for i in range(6,-1,-1):
            f=(today - timedelta(days=i)).isoformat()
            vals=[]
            for m in MACHINES:
                a=acum_por_fecha(leer_csv_dict(m["oee_csv"]), f)
                if a["total"]>0 and a["meta_pzs"]>0: vals.append(a["oee_pct"])
            oee = (sum(vals)/len(vals)) if vals else 0.0
            out.append((f,oee))
        return out

    def _draw_mini_charts(self):
        # limpia
        for fr in (self.chart_area_frame, self.chart_today_frame):
            for w in fr.winfo_children(): w.destroy()

        sns.set_theme(style="whitegrid")

        # 7 días OEE Área (línea + relleno + labels)
        data=self._last7_area()
        if data:
            df=pd.DataFrame(data, columns=["fecha","oee"])
            fig, ax = plt.subplots(figsize=(7.5,2.6), dpi=120)
            sns.lineplot(ax=ax, data=df, x="fecha", y="oee", marker="o")
            ax.fill_between(df["fecha"], df["oee"], 0, alpha=0.15)
            for x, y in zip(df["fecha"], df["oee"]):
                ax.text(x, y+2, f"{y:.0f}%", ha="center", va="bottom", fontsize=8)
            ax.set_ylim(0,100); ax.set_ylabel("OEE %"); ax.set_xlabel(""); ax.grid(True, alpha=0.25)
            canvas=FigureCanvasTkAgg(fig, master=self.chart_area_frame)
            canvas.draw(); canvas.get_tk_widget().pack(fill="x", padx=8, pady=8); plt.close(fig)

        # Buenas vs Scrap (hoy) — barras anotadas
        hoy=date.today().isoformat()
        good=bad=0
        for m in MACHINES:
            a=acum_por_fecha(leer_csv_dict(m["oee_csv"]), hoy); good+=a["buenas"]; bad+=a["scrap"]
        df2=pd.DataFrame({"tipo":["Buenas","Scrap"],"pzs":[good,bad]})
        fig2, ax2 = plt.subplots(figsize=(5.8,2.6), dpi=120)
        sns.barplot(ax=ax2, data=df2, x="tipo", y="pzs")
        for p in ax2.patches:
            ax2.annotate(f"{int(p.get_height())}", (p.get_x()+p.get_width()/2, p.get_height()),
                         ha="center", va="bottom", fontsize=9, xytext=(0,3), textcoords="offset points")
        ax2.set_xlabel(""); ax2.set_ylabel("Piezas"); ax2.grid(True, axis="y", alpha=0.25)
        canvas2=FigureCanvasTkAgg(fig2, master=self.chart_today_frame)
        canvas2.draw(); canvas2.get_tk_widget().pack(fill="x", padx=8, pady=8); plt.close(fig2)

        # Producción buenas por máquina (hoy)
        goods=[]
        for m in MACHINES:
            a=acum_por_fecha(leer_csv_dict(m["oee_csv"]), hoy)
            goods.append({"maquina":m["name"], "buenas":a["buenas"]})
        df3=pd.DataFrame(goods)
        fig3, ax3 = plt.subplots(figsize=(5.8,2.6), dpi=120)
        sns.barplot(ax=ax3, data=df3, x="maquina", y="buenas")
        for p in ax3.patches:
            ax3.annotate(f"{int(p.get_height())}", (p.get_x()+p.get_width()/2, p.get_height()),
                         ha="center", va="bottom", fontsize=9, xytext=(0,3), textcoords="offset points")
        ax3.set_xlabel(""); ax3.set_ylabel("Buenas"); ax3.grid(True, axis="y", alpha=0.25)
        canvas3=FigureCanvasTkAgg(fig3, master=self.chart_today_frame)
        canvas3.draw(); canvas3.get_tk_widget().pack(fill="x", padx=8, pady=8); plt.close(fig3)

    def _refresh_now(self):
        self.clock_lbl.configure(text=datetime.now().strftime("%d/%m/%Y %H:%M:%S"))
        hoy = date.today().isoformat()

        # OEE Área
        oees=[]
        for m in MACHINES:
            a = acum_por_fecha(leer_csv_dict(m["oee_csv"]), hoy)
            if a["total"]>0 and a["meta_pzs"]>0: oees.append(a["oee_pct"])
        area = (sum(oees)/len(oees)) if oees else 0.0
        self.lbl_area.configure(text=f"{area:.2f} %")

        # por máquina (RT + día)
        for m in MACHINES:
            r = resumen_hoy_maquina(m, hoy)
            card = self.cards[m["id"]]
            card["oee"].configure(text=f"OEE (RT) {r['oee']:.2f}%")
            card["A"].configure(text=f"A {r['A']:.2f}%")
            card["P"].configure(text=f"P {r['P']:.2f}%")
            card["Q"].configure(text=f"Q {r['Q']:.2f}%")
            card["dia"].configure(text=f"OEE día: {r['oee_dia']:.2f}%")
            card["paro"].configure(text=f"Último paro: {r['ultimo_paro']}")
            bg, _ = self._tone(r["oee_dia"])
            try: card["wrap"].configure(fg_color=bg)
            except: pass

        self._draw_mini_charts()
        if self._timer: self.after_cancel(self._timer)
        self._timer = self.after(DASH_REFRESH_MS, self._refresh_now)

# ---------- Menú ----------
class MainMenu(ctk.CTkFrame):
    def __init__(self, master, app):
        super().__init__(master, fg_color="transparent")
        box=ctk.CTkFrame(self, corner_radius=20); box.pack(expand=True, fill="both", padx=40, pady=40)
        try:
            img=Image.open(LOGO_PATH); logo=ctk.CTkImage(light_image=img, dark_image=img, size=(240,96))
            ctk.CTkLabel(box, image=logo, text="").pack(pady=(30,10)); self.logo=logo
        except:
            ctk.CTkLabel(box, text="MEFRUP", font=ctk.CTkFont("Helvetica",36,"bold")).pack(pady=(50,10))
        ctk.CTkLabel(box, text="Mefrup MLS", font=ctk.CTkFont("Helvetica",28,"bold")).pack(pady=(0,6))
        ctk.CTkLabel(box, text="Sistema de Monitoreo y Producción", font=ctk.CTkFont("Helvetica",14)).pack(pady=(0,20))
        ctk.CTkButton(box, text="Tablero en vivo (Área Inyección)", height=48, corner_radius=14,
                      command=app.go_dashboard).pack(pady=(0,12), ipadx=20)
        ctk.CTkButton(box, text="OEE y Registro de Producción", height=48, corner_radius=14,
                      command=app.go_oee_select_machine).pack(pady=(0,12), ipadx=20)
        ctk.CTkButton(box, text="Recetas (Moldes/Partes)", height=44, corner_radius=14,
                      fg_color="#E5E7EB", text_color="#111", hover_color="#D1D5DB",
                      command=app.go_recipes).pack(pady=(0,8), ipadx=20)
        ctk.CTkButton(box, text="Planificación + Milestones", height=44, corner_radius=14,
                      command=app.go_planning).pack(pady=(0,8), ipadx=20)
        ctk.CTkButton(box, text="Tablero de Órdenes (Progreso)", height=44, corner_radius=14,
                      command=app.go_orders_board).pack(pady=(0,8), ipadx=20)
        ctk.CTkButton(box, text="Salida de Piezas (Embarques)", height=44, corner_radius=14,
                      command=app.go_shipments).pack(pady=(0,8), ipadx=20)
        # === NUEVO:
        ctk.CTkButton(box, text="Reportes (KPIs & Gráficas)", height=44, corner_radius=14,
                      command=app.go_reports).pack(pady=(0,8), ipadx=20)

# ---------- App ----------
class App(ctk.CTk):
    def __init__(self):
        super().__init__()
        ctk.set_appearance_mode("light"); ctk.set_default_color_theme("blue")
        self.title("Mefrup — ALS")
        try: self.state("zoomed")
        except: self.geometry(f"{self.winfo_screenwidth()}x{self.winfo_screenheight()}")
        self._error_showing=False; self._update_job=None; self._last_tick_value=None; self._clock_label=None
        # estado OEE
        self.operador=tk.StringVar(value=""); self.turno=tk.IntVar(value=0)
        self.molde=tk.StringVar(value="")  # <<< string para no romper IDs de molde
        self.parte=tk.StringVar(value=""); self.ciclo_s=tk.IntVar(value=0)
        self.total=tk.StringVar(value="0"); self.scrap=tk.StringVar(value="0")
        self.fecha_sel=tk.StringVar(value=date.today().isoformat())
        # cronómetro paros
        self.paro_running=False; self.paro_accum_secs=0; self.paro_start_ts=None
        self.paro_motivo=""; self.paro_nota=""
        # métricas / labels
        self.avail_rt=tk.StringVar(value="0.00%"); self.perf_rt=tk.StringVar(value="0.00%")
        self.qual_rt=tk.StringVar(value="0.00%"); self.oee_rt=tk.StringVar(value="0.00%")
        self.tot_day=tk.StringVar(value="0"); self.scr_day=tk.StringVar(value="0"); self.buen_day=tk.StringVar(value="0")
        self.perf_day=tk.StringVar(value="0.00%"); self.qual_day=tk.StringVar(value="0.00%"); self.oee_day=tk.StringVar(value="0.00%")
        self.day_info=tk.StringVar(value="Sin registros para la fecha."); self.oee_hist=tk.StringVar(value="0.00%")
        self.glob_total=tk.StringVar(value="0"); self.glob_scrap=tk.StringVar(value="0"); self.glob_buenas=tk.StringVar(value="0")
        self.glob_perf=tk.StringVar(value="0.00%"); self.glob_qual=tk.StringVar(value="0.00%"); self.glob_oee=tk.StringVar(value="0.00%")
        self.glob_info=tk.StringVar(value="Registros: 0 | Días: 0")
        # recetas catalog
        asegurar_archivos_basicos(); self.recipes = leer_csv_dict(RECIPES_CSV); self.recipe_map = {}
        # vistas / contexto
        self.active_machine = None; self.oee_page = None; self.choose_page = None; self.oee_pages = {}
        self.machine_context = {}; self.dashboard_page = None
        # planificación
        self.planning_page = None; self.orders_board_page = None; self.shipments_page = None; self.reports_page = None
        self._shipments_preselect_order = None
        # recalculo en tiempo real
        self.turno.trace_add("write", lambda *a: self._schedule_update())
        self.molde.trace_add("write", lambda *a: self._on_molde_change())
        self.total.trace_add("write", lambda *a: self._soft_sanitize(self.total, schedule=True))
        self.scrap.trace_add("write", lambda *a: self._soft_sanitize(self.scrap, schedule=True))
        # contenedor & vistas
        self.container=ctk.CTkFrame(self, corner_radius=0, fg_color="transparent"); self.container.pack(fill="both", expand=True)
        self.menu_page=MainMenu(self.container, self)
        self.recipes_page=RecipesView(self.container, self)
        self.choose_page=MachineChooser(self.container, self)
        self.dashboard_page=LiveDashboard(self.container, self)
        self._refresh_moldes_from_recipes(); self.go_menu()
        self.after(TICK_MS, self._tick); self.after(200, self._apply_initial_scale)
    def _set_text_if_changed(self, widget, text: str):
        if getattr(widget, "_last_text", None) != text:
            widget.configure(text=text); widget._last_text = text
    def _set_pb_if_changed(self, pb, frac: float, eps: float = 1e-3):
        frac = max(0.0, min(1.0, float(frac)))
        if abs(getattr(pb, "_last_val", -1.0) - frac) > eps:
            pb.set(frac); pb._last_val = frac
    # navegación
    def _pack_only(self, view):
        for w in self.container.winfo_children(): w.pack_forget()
        view.pack(fill="both", expand=True)
    def go_menu(self):
        self._unbind_shortcuts_oee()
        self._pack_only(self.menu_page)

    def go_dashboard(self):
        self._unbind_shortcuts_oee()
        self._pack_only(self.dashboard_page)

    def go_oee_select_machine(self):
        self._unbind_shortcuts_oee()
        self._pack_only(self.choose_page)

    def go_oee(self, machine):
        self.active_machine = machine
        asegurar_archivos_maquina(machine)
        if machine["id"] not in self.oee_pages:
            self.oee_pages[machine["id"]] = OEEView(self.container, self, machine)
        self.oee_page = self.oee_pages[machine["id"]]
        self._refresh_moldes_from_recipes(force_update_menu=True)
        self._pack_only(self.oee_page)
        self._bind_shortcuts_oee()
        self._update_now(); self._refrescar_dia(); self._refrescar_hist(); self._refrescar_global()
        self._update_save_state(); self._refresh_paro_labels(); self._reload_downtime_table()

    def go_recipes(self):
        self._unbind_shortcuts_oee()
        self._pack_only(self.recipes_page)

    def go_planning(self):
        try:
            if not self.planning_page:
                self.planning_page = PlanningMilestonesView(self.container, self)  # definida más abajo si ya la tienes
            self._pack_only(self.planning_page)
        except NameError:
            messagebox.showinfo("Planificación", "La vista de Planificación se carga más abajo en el archivo.")

    def go_orders_board(self):
        try:
            if not self.orders_board_page:
                self.orders_board_page = OrdersBoardView(self.container, self)
            self._pack_only(self.orders_board_page)
        except NameError:
            messagebox.showinfo("Órdenes", "La vista de Órdenes se carga más abajo en el archivo.")

    def go_shipments(self, preselect_order=None):
        self._shipments_preselect_order = preselect_order
        try:
            if not self.shipments_page:
                self.shipments_page = ShipmentsView(self.container, self)
            self._pack_only(self.shipments_page)
            if preselect_order and hasattr(self.shipments_page, "set_order"):
                self.shipments_page.set_order(preselect_order)
        except NameError:
            messagebox.showinfo("Embarques", "La vista de Salidas se carga más abajo en el archivo.")

    def go_reports(self):
        try:
            if not self.reports_page:
                self.reports_page = ReportsView(self.container, self)
            self._pack_only(self.reports_page)
        except NameError:
            messagebox.showinfo("Reportes", "La vista de Reportes se carga más abajo en el archivo.")

    # ======== atajos ========
    def _bind_shortcuts_oee(self):
        self.unbind("<Control-Return>"); self.bind("<Control-Return>", lambda e: self._guardar())
        self.unbind("<Control-g>"); self.bind("<Control-g>", lambda e: self._nudge(self.total,+1))
        self.unbind("<Control-h>"); self.bind("<Control-h>", lambda e: self._nudge(self.total,-1))
        self.unbind("<Control-s>"); self.bind("<Control-s>", lambda e: self._nudge(self.scrap,+1))
        self.unbind("<Control-d>"); self.bind("<Control-d>", lambda e: self._nudge(self.scrap,-1))

    def _unbind_shortcuts_oee(self):
        self.unbind("<Control-Return>"); self.unbind("<Control-g>"); self.unbind("<Control-h>")
        self.unbind("<Control-s>"); self.unbind("<Control-d>")

    # ======== manejo de errores ========
    def report_callback_exception(self, exc, val, tb):
        try:
            logging.basicConfig(filename=os.path.join(BASE_DIR,"ui_errors.log"),
                                level=logging.ERROR,filemode="a")
            logging.error("".join(traceback.format_exception(exc,val,tb)))
        except:
            pass
        if getattr(self,"_error_showing",False): return
        self._error_showing=True
        try:
            messagebox.showerror("Error en la UI", f"{val}\n(Detalle en ui_errors.log)")
        finally:
            self.after(200, lambda: setattr(self,"_error_showing",False))

    # ======== setters desde UI ========
    def _set_operador(self, nombre:str):
        self.operador.set(nombre or ""); self._update_save_state()

    def _set_turno(self, turno_val):
        try: self.turno.set(int(turno_val))
        except: self.turno.set(0)
        self._update_now(); self._update_save_state()

    def _set_molde(self, molde_val):
        v = (molde_val or "").strip()
        self.molde.set(v)
        try:
            if hasattr(self, "molde_menu"):
                vals = self.molde_menu.cget("values")
                if v in vals: self.molde_menu.set(v)
        except: pass
        self._update_save_state()

    # ======== recetas / moldes ========
    def _refresh_moldes_from_recipes(self, force_update_menu=False):
        self.recipes = leer_csv_dict(RECIPES_CSV)
        self.recipe_map = {}
        opciones = ["Selecciona"]
        for r in self.recipes:
            if r.get("activo","1") == "1":
                mid = (r.get("molde_id") or "").strip()
                if mid:
                    self.recipe_map[mid] = r
                    opciones.append(mid)
        if hasattr(self, "molde_menu"):
            try:
                self.molde_menu.configure(values=opciones)
                cur = (self.molde.get() or "")
                if cur not in opciones:
                    self.molde.set(""); self.ciclo_s.set(0); self.parte.set("")
                if force_update_menu and cur in opciones:
                    self.molde_menu.set(cur if cur else "Selecciona")
            except: pass
        if force_update_menu and self.oee_page:
            try: self._on_molde_change()
            except: pass

    def _on_molde_change(self, *_):
        mid = (self.molde.get() or "").strip()
        rec = self.recipe_map.get(mid)
        if rec:
            self.parte.set((rec.get("parte") or "").strip())
            raw=(rec.get("ciclo_ideal_s") or "").replace(",",".").strip()
            try: self.ciclo_s.set(int(float(raw)))
            except: self.ciclo_s.set(0)
            self.rec_cavs=(rec.get("cavidades") or "").strip()
            self.rec_cavs_on=(rec.get("cavidades_habilitadas") or "").strip()
            self.rec_scrap=(rec.get("scrap_esperado_pct") or "").strip()
        else:
            self.parte.set(""); self.ciclo_s.set(0)
            self.rec_cavs=self.rec_cavs_on=self.rec_scrap=""
        if hasattr(self,"lbl_parte"):
            try: self.lbl_parte.configure(text=self.parte.get() or "-")
            except: pass
        if hasattr(self,"lbl_cavs"):
            try:
                cavs_on=getattr(self,"rec_cavs_on","") or "-"
                cavs=getattr(self,"rec_cavs","") or "-"
                self.lbl_cavs.configure(text=f"{cavs_on}/{cavs}")
            except: pass
        self._schedule_update()

    # ======== entrada / sanitizado ========
    def _get_int(self, v:tk.StringVar):
        s=(v.get() or "").strip()
        if s.startswith("-"): s=s[1:]
        return int(s) if s.isdigit() else 0

    def _set_int(self, v:tk.StringVar, n:int):
        v.set(str(max(0,int(n))))

    def _sanitize(self, v:tk.StringVar):
        self._set_int(v, self._get_int(v)); self._update_now()

    def _nudge(self, v:tk.StringVar, d:int):
        self._set_int(v, self._get_int(v)+d); self._update_now()

    def _soft_sanitize(self, var: tk.StringVar, schedule=False):
        s=(var.get() or "")
        ns="".join(ch for ch in s if ch.isdigit())
        if ns!=s: var.set(ns)
        if var is self.scrap:
            try:
                t=int(self.total.get() or 0); sc=int(self.scrap.get() or 0)
                if sc>t: self.scrap.set(str(t))
            except: pass
        if schedule: self._schedule_update()

    # ======== debounce ========
    def _schedule_update(self):
        if self._update_job: self.after_cancel(self._update_job)
        self._update_job = self.after(DEBOUNCE_MS, self._update_now)

    def _update_now(self):
        self._update_job=None
        self._update_calculos()

    # ======== fecha ========
    def _on_fecha_change(self):
        f=self.fecha_sel.get().strip()
        try: y,m,d=map(int,f.split("-")); _=date(y,m,d)
        except:
            messagebox.showwarning("Fecha inválida","Usa YYYY-MM-DD."); return
        if self.oee_page and hasattr(self.oee_page,"lbl_dia"):
            self.oee_page.lbl_dia.configure(text=f"{dia_semana_es(f)} — {f}")
        self._refrescar_dia(); self._update_save_state(); self._reload_downtime_table()

    def _open_calendar(self):
        try:
            y,m,d=map(int,(self.fecha_sel.get() or date.today().isoformat()).split("-"))
            init=date(y,m,d)
        except:
            init=date.today()
        top=tk.Toplevel(self); top.title("Selecciona fecha"); top.transient(self); top.grab_set(); top.resizable(False,False)
        self.update_idletasks()
        top.geometry(f"+{self.winfo_rootx()+self.winfo_width()//2-180}+{self.winfo_rooty()+self.winfo_height()//2-170}")
        cal=Calendar(top, selectmode="day", year=init.year, month=init.month, day=init.day, date_pattern="yyyy-mm-dd",
                     firstweekday="monday", showweeknumbers=False)
        cal.pack(padx=14, pady=14)
        b=tk.Frame(top); b.pack(fill="x", padx=14, pady=(0,14))
        def choose():
            ch=cal.get_date()
            self.fecha_sel.set(ch); self._on_fecha_change(); top.destroy()
        tk.Button(b, text="Seleccionar", command=choose).pack(side="left", padx=(0,6))
        tk.Button(b, text="Cerrar", command=top.destroy).pack(side="left")

    # ======== paros / cronómetro ========
    def toggle_paro(self):
        if not self.active_machine:
            messagebox.showwarning("Máquina","Primero elige una máquina."); return
        if not self.paro_running:
            motivo = getattr(self, "motivo_menu", None).get() if hasattr(self, "motivo_menu") else MOTIVOS_PARO[0]
            nota   = getattr(self, "nota_entry", None).get() if hasattr(self, "nota_entry") else ""
            self.paro_motivo=motivo; self.paro_nota=nota
            self.paro_running=True; self.paro_start_ts=datetime.now()
            self.btn_toggle_paro.configure(text="Reanudar", fg_color="#10b981", hover_color="#059669")
        else:
            self._finalizar_evento_paro()
            self.paro_running=False; self.paro_start_ts=None
            self.paro_motivo=""; self.paro_nota=""
            self.btn_toggle_paro.configure(text="Iniciar paro", fg_color="#ef4444", hover_color="#dc2626")
        self._refresh_paro_labels(); self._schedule_update(); self._update_save_state()

    def _finalizar_evento_paro(self):
        if not (self.paro_start_ts and self.active_machine): return
        dur=int((datetime.now()-self.paro_start_ts).total_seconds())
        self.paro_accum_secs += max(0,dur)
        row=[self.fecha_sel.get().strip(),
             self.paro_start_ts.strftime("%Y-%m-%d %H:%M:%S"),
             datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
             str(dur), self.paro_motivo, self.paro_nota,
             self.operador.get(), str(self.turno.get() or ""), self.molde.get() or ""]
        try:
            with open(self.active_machine["down_csv"],"a",newline="",encoding="utf-8") as f:
                csv.writer(f).writerow(row)
        except PermissionError:
            messagebox.showerror("Archivo en uso","Cierra el CSV de paros.")
        self._reload_downtime_table()

    def reset_paros(self):
        if self.paro_running:
            messagebox.showwarning("Paro activo","Detén el paro antes de reiniciar."); return
        if messagebox.askyesno("Reset de paros","¿Reiniciar a 00:00:00 el paro acumulado del turno?"):
            self.paro_accum_secs=0; self._refresh_paro_labels(); self._schedule_update()

    def _current_paro_secs(self):
        return int((datetime.now()-self.paro_start_ts).total_seconds()) if (self.paro_running and self.paro_start_ts) else 0

    def _total_paro_secs(self):
        return self.paro_accum_secs + self._current_paro_secs()

    def _refresh_paro_labels(self):
        if hasattr(self,"lbl_paro_actual"): self.lbl_paro_actual.configure(text=segs_to_hms_str(self._current_paro_secs()))
        if hasattr(self,"lbl_paro_acum"):   self.lbl_paro_acum.configure(text=segs_to_hms_str(self._total_paro_secs()))

    def _tick(self):
        if self._clock_label:
            self._clock_label.configure(text=datetime.now().strftime("%d/%m/%Y %H:%M:%S"))
        now_val = self._current_paro_secs() if self.paro_running else None
        if now_val is not None and now_val != self._last_tick_value:
            self._last_tick_value = now_val
            self._refresh_paro_labels()
            self._schedule_update()
        self.after(TICK_MS, self._tick)

    def _reload_downtime_table(self):
        if not (hasattr(self, "tree") and self.active_machine): return
        for i in self.tree.get_children(): self.tree.delete(i)
        f=self.fecha_sel.get().strip()
        for r in leer_csv_dict(self.active_machine["down_csv"]):
            if r.get("fecha")!=f: continue
            try: dmin = round(int(float(r.get("duracion_seg","0")))/60.0,1)
            except: dmin=0.0
            self.tree.insert("", "end", values=(r.get("inicio_ts",""), r.get("fin_ts",""),
                                                r.get("motivo",""), r.get("nota",""), f"{dmin:.1f}"))

    # ======== cálculos + guardar ========
    def _update_calculos(self):
        horas = TURNOS_HORAS.get(int(self.turno.get() or 0), 0)
        ciclo = int(self.ciclo_s.get() or 0)
        turno_seg, oper_seg, meta_plan, meta_oper = calcular_tiempos(horas, ciclo, self._total_paro_secs())
        if hasattr(self,"meta_plan_val"): self._set_text_if_changed(self.meta_plan_val, str(meta_plan))
        if hasattr(self,"meta_oper_val"): self._set_text_if_changed(self.meta_oper_val, str(meta_oper))

        total=self._get_int(self.total); scrap=min(self._get_int(self.scrap), total)
        buenas, A, P, Q, OEE = calcular_metricas(total, scrap, turno_seg, oper_seg, ciclo)
        self.avail_rt.set(f"{A:.2f}%"); self.perf_rt.set(f"{P:.2f}%")
        self.qual_rt.set(f"{Q:.2f}%");  self.oee_rt.set(f"{OEE:.2f}%")
        if hasattr(self,"pb_avail"):   self._set_pb_if_changed(self.pb_avail, A/100.0)
        if hasattr(self,"pb_meta"):    self._set_pb_if_changed(self.pb_meta,  (total/meta_oper) if meta_oper>0 else 0.0)
        if hasattr(self,"pb_quality"): self._set_pb_if_changed(self.pb_quality, (buenas/total) if total>0 else 0.0)

    def _turno_bloqueado_maquina(self, machine, fecha_iso, turno:int) -> bool:
        rows = leer_csv_dict(machine["oee_csv"])
        for r in rows:
            try:
                if r.get("fecha")==fecha_iso and int(float(r.get("turno","0")))==int(turno):
                    return True
            except: pass
        return False

    def _guardar(self):
        if not self.active_machine:
            messagebox.showwarning("Máquina","Primero elige una máquina."); return
        f=self.fecha_sel.get().strip()
        if self.paro_running:
            messagebox.showwarning("Paro activo","Detén el paro antes de guardar."); return
        if not (self.operador.get() and self.turno.get() and self.molde.get()):
            messagebox.showwarning("Faltan datos","Selecciona operador, turno y molde."); return
        try: y,m,d=map(int,f.split("-")); _=date(y,m,d)
        except:
            messagebox.showwarning("Fecha inválida","Usa YYYY-MM-DD."); return
        if self._turno_bloqueado_maquina(self.active_machine, f, int(self.turno.get())):
            messagebox.showwarning("Turno ya registrado", f"{f} — turno {self.turno.get()} ya fue registrado en {self.active_machine['name']}."); 
            return

        total=self._get_int(self.total); scrap=min(self._get_int(self.scrap), total)
        paro_seg=self._total_paro_secs()
        horas=TURNOS_HORAS.get(int(self.turno.get() or 0),0); ciclo=int(self.ciclo_s.get() or 0)
        turno_seg, oper_seg, _, meta_oper = calcular_tiempos(horas, ciclo, paro_seg)
        buenas, A, P, Q, OEE = calcular_metricas(total, scrap, turno_seg, oper_seg, ciclo)

        ts=f"{f}T{datetime.now().strftime('%H:%M:%S')}"
        row=[ts,f,self.operador.get(),self.turno.get(),self.molde.get(),self.parte.get(),ciclo,horas,
             int(round(paro_seg/60.0)), meta_oper,total,scrap,buenas,A,P,Q,OEE]
        try:
            with open(self.active_machine["oee_csv"],"a",newline="",encoding="utf-8") as fi:
                csv.writer(fi).writerow(row)
        except PermissionError:
            messagebox.showerror("Archivo en uso","Cierra el CSV de la máquina y vuelve a intentar."); return

        rows_maquina = leer_csv_dict(self.active_machine["oee_csv"])
        a=acum_por_fecha(rows_maquina, f)
        escribir_daily(DAILY_CSV_GLOBAL, f, a["oee_pct"], a["total"], a["scrap"], a["meta_pzs"])

        # actualizado: OEE del área = promedio del OEE día de cada máquina
        oees=[]
        for m in MACHINES:
            r = acum_por_fecha(leer_csv_dict(m["oee_csv"]), f)
            if r["total"]>0 and r["meta_pzs"]>0:
                oees.append(r["oee_pct"])
        OEE_area = (sum(oees)/len(oees)) if oees else 0.0
        total_area = sum(acum_por_fecha(leer_csv_dict(m["oee_csv"]), f)["total"] for m in MACHINES)
        scrap_area = sum(acum_por_fecha(leer_csv_dict(m["oee_csv"]), f)["scrap"] for m in MACHINES)
        meta_area  = sum(acum_por_fecha(leer_csv_dict(m["oee_csv"]), f)["meta_pzs"] for m in MACHINES)
        escribir_daily(DAILY_CSV_INJECTOR, f, OEE_area, total_area, scrap_area, meta_area)

        self._refrescar_dia(); self._refrescar_hist(); self._refrescar_global(); self._update_save_state()
        messagebox.showinfo("Guardado",
                            f"Máquina: {self.active_machine['name']}\n"
                            f"OEE {OEE:.2f}% (A {A:.2f}% | P {P:.2f}% | Q {Q:.2f}%)")

    def _refrescar_dia(self):
        if not self.active_machine: return
        f=self.fecha_sel.get().strip()
        if self.oee_page and hasattr(self.oee_page,"lbl_dia"):
            self.oee_page.lbl_dia.configure(text=f"{dia_semana_es(f)} — {f}")
        a=acum_por_fecha(leer_csv_dict(self.active_machine["oee_csv"]), f)
        self.tot_day.set(str(a["total"])); self.scr_day.set(str(a["scrap"])); self.buen_day.set(str(a["buenas"]))
        self.perf_day.set(f"{a['perf_pct']:.2f}%"); self.qual_day.set(f"{a['qual_pct']:.2f}%"); self.oee_day.set(f"{a['oee_pct']:.2f}%")
        self.day_info.set("Registros del día: "+str(a.get("count",0)) if a.get("count",0) else "Sin registros para la fecha.")

    def _refrescar_hist(self):
        self.oee_hist.set(f"{promedio_oee_daily(DAILY_CSV_GLOBAL):.2f}%")

    def _refrescar_global(self):
        if not self.active_machine: return
        g=acum_global(leer_csv_dict(self.active_machine["oee_csv"]))
        self.glob_total.set(str(g["total"])); self.glob_scrap.set(str(g["scrap"])); self.glob_buenas.set(str(g["buenas"]))
        self.glob_perf.set(f"{g['perf_pct']:.2f}%"); self.glob_qual.set(f"{g['qual_pct']:.2f}%"); self.glob_oee.set(f"{g['oee_pct']:.2f}%")
        self.glob_info.set(f"Registros: {g['registros']} | Días: {g['dias']}")

    def _reset_contadores(self):
        if self.paro_running:
            messagebox.showwarning("Paro activo","Detén el paro antes de resetear."); return
        self.total.set("0"); self.scrap.set("0"); self.paro_accum_secs=0
        self._refresh_paro_labels(); self._update_now()

    def _update_save_state(self):
        ready = bool(self.operador.get()) and bool(self.turno.get()) and bool(self.molde.get()) and self.active_machine
        if self.paro_running: ready=False
        try: self.btn_guardar.configure(state=("normal" if ready else "disabled"))
        except: pass

    def _apply_initial_scale(self):
        try:
            s=min(max(self.winfo_screenwidth()/1920.0, 0.95), 1.20)
            ctk.set_widget_scaling(s)
        except: pass
class ReportsView(ctk.CTkFrame):
    """Reportes por máquina y rango (KPIs + gráficas)."""
    def __init__(self, master, app):
        super().__init__(master, fg_color="transparent")
        self.app = app
        self._build()

    # ---- utilidades UI ----
    def _calendar_pick(self, entry: ctk.CTkEntry):
        try:
            y,m,d=map(int,(entry.get() or date.today().isoformat()).split("-")); init=date(y,m,d)
        except: init=date.today()
        top=tk.Toplevel(self); top.title("Selecciona fecha"); top.transient(self); top.grab_set(); top.resizable(False,False)
        self.update_idletasks()
        top.geometry(f"+{self.winfo_rootx()+self.winfo_width()//2-180}+{self.winfo_rooty()+self.winfo_height()//2-170}")
        cal=Calendar(top, selectmode="day", year=init.year, month=init.month, day=init.day, date_pattern="yyyy-mm-dd",
                     firstweekday="monday", showweeknumbers=False)
        cal.pack(padx=14, pady=14)
        def choose():
            entry.delete(0,"end"); entry.insert(0, cal.get_date()); top.destroy()
        tk.Button(top, text="Seleccionar", command=choose).pack(side="left", padx=10, pady=10)
        tk.Button(top, text="Cerrar", command=top.destroy).pack(side="left", padx=10, pady=10)

    def _build(self):
        header=ctk.CTkFrame(self, corner_radius=0, fg_color=("white","#111111"))
        header.pack(fill="x", side="top")
        left=ctk.CTkFrame(header, fg_color="transparent"); left.pack(side="left", padx=16, pady=10)
        ctk.CTkButton(left, text="← Menú", command=self.app.go_menu, width=110, corner_radius=10,
                      fg_color="#E5E7EB", text_color="#111", hover_color="#D1D5DB").pack(side="left", padx=(0,10))
        ctk.CTkLabel(left, text="Reportes — KPIs y Gráficas",
                     font=ctk.CTkFont("Helvetica",20,"bold")).pack(side="left")

        body=ctk.CTkFrame(self, fg_color="transparent"); body.pack(fill="both", expand=True, padx=16, pady=16)

        # Filtros
        filters=ctk.CTkFrame(body, corner_radius=16); filters.pack(fill="x", padx=0, pady=(0,12))
        ctk.CTkLabel(filters, text="Filtros", font=ctk.CTkFont("Helvetica", 14, "bold")).pack(anchor="w", padx=12, pady=(10,6))
        ctk.CTkFrame(filters, height=1, fg_color=("#E5E7EB","#2B2B2B")).pack(fill="x", padx=12, pady=(0,10))
        row=ctk.CTkFrame(filters, fg_color="transparent"); row.pack(fill="x", padx=12, pady=4)
        self.om_machine = ctk.CTkOptionMenu(row, values=[m["id"] for m in MACHINES], width=160)
        self.om_machine.set(MACHINES[0]["id"]); self.om_machine.pack(side="left", padx=(0,8))
        self.e_from = ctk.CTkEntry(row, placeholder_text="Desde (YYYY-MM-DD)", width=160); self.e_from.pack(side="left", padx=(8,6))
        ctk.CTkButton(row, text="📅", width=36, command=lambda:self._calendar_pick(self.e_from)).pack(side="left")
        self.e_to   = ctk.CTkEntry(row, placeholder_text="Hasta (YYYY-MM-DD)", width=160); self.e_to.pack(side="left", padx=(12,6))
        ctk.CTkButton(row, text="📅", width=36, command=lambda:self._calendar_pick(self.e_to)).pack(side="left", padx=(0,8))
        ctk.CTkButton(row, text="Generar", command=self._run_report).pack(side="left", padx=8)
        ctk.CTkButton(row, text="Exportar CSV", fg_color="#E5E7EB", text_color="#111", hover_color="#D1D5DB",
                      command=self._export_csv).pack(side="left", padx=8)

        # Tarjetas KPI
        self.kpis_wrap = ctk.CTkFrame(body, corner_radius=16); self.kpis_wrap.pack(fill="x", padx=0, pady=(0,12))
        ctk.CTkLabel(self.kpis_wrap, text="KPIs", font=ctk.CTkFont("Helvetica", 14, "bold"))\
            .pack(anchor="w", padx=12, pady=(10,0))
        self.kpi_cards = ctk.CTkFrame(self.kpis_wrap, fg_color="transparent"); self.kpi_cards.pack(fill="x", padx=12, pady=(8,12))

        # Charts
        self.charts = ctk.CTkScrollableFrame(self, corner_radius=0)
        self.charts.pack(fill="both", expand=True, padx=16, pady=(0,16))

        # Default: hoy
        today=date.today().isoformat()
        self.e_from.insert(0, today); self.e_to.insert(0, today)
        self._run_report()

    # ---- cálculos ----
    def _rows_in_range(self, csv_path, start, end):
        out=[]
        for r in leer_csv_dict(csv_path):
            f=r.get("fecha","")
            if not f: continue
            if start and f < start: continue
            if end and f > end: continue
            out.append(r)
        return out

    def _agg(self, rows):
        turno_seg = 0; paro_seg=0; perf_num=0.0; total=0; scrap=0
        for r in rows:
            try: horas=float(str(r.get("horas_turno","0")).replace(",",".")) or 0.0
            except: horas=0.0
            turno_seg += int(horas*3600)
            try: pmin=float(str(r.get("tiempo_paro_min","0")).replace(",",".")) or 0.0
            except: pmin=0.0
            paro_seg += int(pmin*60)
            ciclo = parse_int_str(r.get("ciclo_s","0"),0)
            buenas= parse_int_str(r.get("buenas_pzs","0"),0)
            total += parse_int_str(r.get("total_pzs","0"),0)
            scrap += parse_int_str(r.get("scrap_pzs","0"),0)
            if ciclo>0 and buenas>0:
                perf_num += buenas * ciclo
        oper_seg=max(0, turno_seg - paro_seg)
        A=(oper_seg/turno_seg) if turno_seg>0 else 0.0
        P=(perf_num/oper_seg)  if oper_seg>0 else 0.0
        Q=((total-scrap)/total) if total>0 else 0.0
        O=A*P*Q
        return {
            "turno_seg":turno_seg,"oper_seg":oper_seg,"paro_seg":paro_seg,
            "total":total,"buenas":max(0,total-scrap),"scrap":scrap,
            "A":round(A*100,2),"P":round(P*100,2),"Q":round(Q*100,2),"OEE":round(O*100,2)
        }

    # ---- UI helpers ----
    def _kpi_card(self, parent, title, value, subtitle=None, bg=("#F3F4F6","#1F2937")):
        card = ctk.CTkFrame(parent, corner_radius=14)
        card.pack(side="left", fill="x", expand=True, padx=6)
        ctk.CTkLabel(card, text=title, font=ctk.CTkFont("Helvetica",12)).pack(anchor="w", padx=10, pady=(8,0))
        ctk.CTkLabel(card, text=value, font=ctk.CTkFont("Helvetica",22,"bold")).pack(anchor="w", padx=10, pady=(0,6))
        if subtitle:
            ctk.CTkLabel(card, text=subtitle, text_color=("#6b7280","#9CA3AF")).pack(anchor="w", padx=10, pady=(0,8))
        return card

    def _run_report(self):
        # limpia charts
        for w in self.charts.winfo_children(): w.destroy()
        for w in self.kpi_cards.winfo_children(): w.destroy()

        mid = self.om_machine.get().strip()
        start=self.e_from.get().strip() or None
        end  =self.e_to.get().strip()   or None
        m = next((mm for mm in MACHINES if mm["id"]==mid), MACHINES[0])

        rows = self._rows_in_range(m["oee_csv"], start, end)
        agg  = self._agg(rows)

        # Tarjetas KPI
        self._kpi_card(self.kpi_cards, "Availability", f"{agg['A']:.2f}%")
        self._kpi_card(self.kpi_cards, "Effectivity (P)", f"{agg['P']:.2f}%")
        self._kpi_card(self.kpi_cards, "Quality", f"{agg['Q']:.2f}%")
        self._kpi_card(self.kpi_cards, "OEE", f"{agg['OEE']:.2f}%")
        self._kpi_card(self.kpi_cards, "Buenas", f"{agg['buenas']}")
        self._kpi_card(self.kpi_cards, "Scrap",  f"{agg['scrap']}")
        self._kpi_card(self.kpi_cards, "Total",  f"{agg['total']}")
        def hhmm(secs): secs=max(0,int(secs)); h=secs//3600; mi=(secs%3600)//60; return f"{h:02d}:{mi:02d} h:mm"
        self._kpi_card(self.kpi_cards, "Nom. production time", hhmm(agg["oper_seg"]))
        self._kpi_card(self.kpi_cards, "Total standstills", hhmm(agg["paro_seg"]))

        sns.set_theme(style="whitegrid")

        # KPI barras con labels
        kframe = ctk.CTkFrame(self.charts, corner_radius=16); kframe.pack(fill="x", padx=8, pady=8)
        ctk.CTkLabel(kframe, text=f"KPI — {m['name']}", font=ctk.CTkFont("Helvetica", 13, "bold"))\
            .pack(anchor="w", padx=8, pady=(8,0))
        fig, ax = plt.subplots(figsize=(7.5,2.6), dpi=120)
        dfk = pd.DataFrame({"KPI":["Availability","Effectivity","Quality","OEE"],
                            "Valor":[agg["A"], agg["P"], agg["Q"], agg["OEE"]]})
        sns.barplot(ax=ax, data=dfk, x="KPI", y="Valor")
        ax.set_ylim(0,100); ax.set_ylabel("%"); ax.grid(True, axis="y", alpha=0.25)
        for p, v in zip(ax.patches, dfk["Valor"]):
            ax.annotate(f"{v:.1f}%", (p.get_x()+p.get_width()/2, p.get_height()),
                        ha="center", va="bottom", fontsize=9, xytext=(0,3), textcoords="offset points")
        canvas=FigureCanvasTkAgg(fig, master=kframe); canvas.draw(); canvas.get_tk_widget().pack(fill="x", padx=8, pady=8); plt.close(fig)

        # OEE por día (línea con relleno)
        if rows:
            # agrupación segura por fecha
            sums={}
            for r in rows:
                f=r.get("fecha",""); 
                if not f: continue
                if f not in sums: sums[f]=[]
                sums[f].append(r)
            byday=[]
            for f, rr in sorted(sums.items()):
                a=acum_por_fecha(rr, f); byday.append((f, a["oee_pct"]))
            if byday:
                lframe = ctk.CTkFrame(self.charts, corner_radius=16); lframe.pack(fill="x", padx=8, pady=8)
                ctk.CTkLabel(lframe, text="OEE por día", font=ctk.CTkFont("Helvetica", 13, "bold"))\
                    .pack(anchor="w", padx=8, pady=(8,0))
                dfl = pd.DataFrame(byday, columns=["fecha","OEE"])
                fig2, ax2 = plt.subplots(figsize=(7.5,2.6), dpi=120)
                sns.lineplot(ax=ax2, data=dfl, x="fecha", y="OEE", marker="o")
                ax2.fill_between(dfl["fecha"], dfl["OEE"], 0, alpha=0.15)
                for x, y in zip(dfl["fecha"], dfl["OEE"]):
                    ax2.text(x, y+2, f"{y:.0f}%", ha="center", va="bottom", fontsize=8)
                ax2.set_ylim(0,100); ax2.grid(True, alpha=0.25); ax2.set_xlabel(""); ax2.set_ylabel("%")
                canvas2=FigureCanvasTkAgg(fig2, master=lframe); canvas2.draw(); canvas2.get_tk_widget().pack(fill="x", padx=8, pady=8); plt.close(fig2)

        # Buenas vs Scrap (barras apiladas por total)
        bframe = ctk.CTkFrame(self.charts, corner_radius=16); bframe.pack(fill="x", padx=8, pady=8)
        ctk.CTkLabel(bframe, text="Buenas vs Scrap", font=ctk.CTkFont("Helvetica", 13, "bold"))\
            .pack(anchor="w", padx=8, pady=(8,0))
        figb, axb = plt.subplots(figsize=(7.5,2.2), dpi=120)
        total = max(1, agg["total"]); buenas = agg["buenas"]; scrap = agg["scrap"]
        axb.bar(["Piezas"], [buenas], label="Buenas")
        axb.bar(["Piezas"], [scrap], bottom=[buenas], label="Scrap")
        axb.set_ylim(0, total*1.15); axb.grid(True, axis="y", alpha=0.25); axb.legend()
        axb.annotate(f"{buenas} ({buenas/total*100:.1f}%)", (0, buenas), ha="center", va="bottom", fontsize=9, xytext=(0,3), textcoords="offset points")
        axb.annotate(f"{scrap} ({scrap/total*100:.1f}%)", (0, buenas+scrap), ha="center", va="bottom", fontsize=9, xytext=(0,3), textcoords="offset points")
        canvasb=FigureCanvasTkAgg(figb, master=bframe); canvasb.draw(); canvasb.get_tk_widget().pack(fill="x", padx=8, pady=8); plt.close(figb)

        # Causas de paro (Top ordenadas)
        downs = self._rows_in_range(m["down_csv"], start, end)
        causas={}
        for r in downs:
            mot=(r.get("motivo","") or "—").strip()
            try: mins = round(int(float(r.get("duracion_seg","0")))/60.0,1)
            except: mins = 0.0
            causas[mot]=causas.get(mot,0.0)+mins
        if causas:
            cframe = ctk.CTkFrame(self.charts, corner_radius=16); cframe.pack(fill="x", padx=8, pady=8)
            ctk.CTkLabel(cframe, text="Standstills por causa (min)", font=ctk.CTkFont("Helvetica", 13, "bold"))\
                .pack(anchor="w", padx=8, pady=(8,0))
            dfc = pd.DataFrame({"Causa": list(causas.keys()), "Minutos": list(causas.values())})\
                    .sort_values("Minutos", ascending=False)
            fig3, ax3 = plt.subplots(figsize=(7.5,2.8), dpi=120)
            sns.barplot(ax=ax3, data=dfc, x="Minutos", y="Causa", orient="h")
            for p, v in zip(ax3.patches, dfc["Minutos"]):
                ax3.annotate(f"{v:.1f}", (p.get_x()+p.get_width(), p.get_y()+p.get_height()/2),
                             ha="left", va="center", fontsize=9, xytext=(3,0), textcoords="offset points")
            ax3.grid(True, axis="x", alpha=0.25)
            canvas3=FigureCanvasTkAgg(fig3, master=cframe); canvas3.draw(); canvas3.get_tk_widget().pack(fill="x", padx=8, pady=8); plt.close(fig3)

    def _export_csv(self):
        mid = self.om_machine.get().strip()
        start=self.e_from.get().strip() or None
        end  =self.e_to.get().strip()   or None
        m = next((mm for mm in MACHINES if mm["id"]==mid), MACHINES[0])
        rows = self._rows_in_range(m["oee_csv"], start, end)
        if not rows:
            messagebox.showinfo("Exportar","No hay registros en el rango."); return
        out_path = os.path.join(BASE_DIR, f"reporte_{mid}_{start or 'ini'}_{end or 'fin'}.csv")
        cols=["timestamp","fecha","operador","turno","molde","parte","ciclo_s","horas_turno",
              "tiempo_paro_min","meta_oper_pzs","total_pzs","scrap_pzs","buenas_pzs",
              "availability_%","performance_%","quality_%","oee_%"]
        with open(out_path,"w",newline="",encoding="utf-8") as f:
            w=csv.DictWriter(f, fieldnames=cols); w.writeheader()
            for r in rows: w.writerow({k:r.get(k,"") for k in cols})
        messagebox.showinfo("Exportar", f"Reporte guardado:\n{out_path}")

    App().mainloop()
