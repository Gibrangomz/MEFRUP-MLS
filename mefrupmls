# -*- coding: utf-8 -*-
# Requisitos:
#   pip install customtkinter pillow tkcalendar pandas matplotlib seaborn
import customtkinter as ctk
import tkinter as tk
from tkinter import messagebox, ttk
from PIL import Image
from tkcalendar import Calendar
import csv, os, logging, traceback
from datetime import datetime, date, timedelta

# === NUEVO: libs para reportes/gr√°ficas
import pandas as pd
import matplotlib
matplotlib.use("Agg")  # backend offscreen para generar figuras y luego embederlas
import matplotlib.pyplot as plt
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
import seaborn as sns

# ---------- rutas / const ----------
BASE_DIR    = os.path.dirname(os.path.abspath(__file__))

# CSVs por m√°quina
MACHINES = [
    {
        "id": "arburg",
        "name": "ARBURG 320C GOLDEN EDITION",
        "oee_csv":  os.path.join(BASE_DIR, "oee_arburg.csv"),
        "down_csv": os.path.join(BASE_DIR, "down_arburg.csv")
    },
    {
        "id": "yizumi",
        "name": "YIZUMI UN90 A5",
        "oee_csv":  os.path.join(BASE_DIR, "oee_yizumi.csv"),
        "down_csv": os.path.join(BASE_DIR, "down_yizumi.csv")
    }
]

# diarios (compat) + combinado
DAILY_CSV_GLOBAL   = os.path.join(BASE_DIR, "oee_daily.csv")
DAILY_CSV_INJECTOR = os.path.join(BASE_DIR, "oee_inyeccion_daily.csv")

RECIPES_CSV = os.path.join(BASE_DIR, "recipes.csv")
LOGO_PATH   = os.path.join(BASE_DIR, "10b41fef-97af-4e79-90c4-b496e0dd3197.png")

# planificaci√≥n y milestones
PLANNING_CSV = os.path.join(BASE_DIR, "planning.csv")   # orden, parte, molde_id, maquina_id, qty_total, inicio_ts, fin_est_ts, setup_min, estado, ciclo_s, cav_on
DELIV_CSV    = os.path.join(BASE_DIR, "deliveries.csv") # orden, due_date, qty, cumplido(0/1)

# NUEVO: salidas / embarques
SHIPMENTS_CSV = os.path.join(BASE_DIR, "shipments.csv") # orden, ship_date, qty, destino, nota

OPERADORES   = ["OPERADOR 1", "OPERADOR 2", "OPERADOR 3"]
TURNOS_HORAS = {1: 8, 2: 8, 3: 8}
DIAS_ES      = ["Lunes","Martes","Mi√©rcoles","Jueves","Viernes","S√°bado","Domingo"]

TICK_MS     = 1000
DEBOUNCE_MS = 160
DASH_REFRESH_MS = 5000

MOTIVOS_PARO = [
    "Cambio de molde",
    "Pieza Atorada",
    "Sin operador",
    "Calidad",
    "Mantenimiento",
    "Energ√≠a (Se fue la luz)"
]

# ---------- CSV utils ----------
def asegurar_csv(path, header):
    try:
        with open(path, "x", newline="", encoding="utf-8") as f:
            csv.writer(f).writerow(header)
    except FileExistsError:
        pass

def leer_csv_dict(path):
    if not os.path.exists(path): return []
    with open(path, "r", newline="", encoding="utf-8") as f:
        return list(csv.DictReader(f))

def escribir_daily(path, fecha_iso, oee_pct, total, scrap, meta):
    asegurar_csv(path, ["fecha","oee_dia_%","total_pzs","scrap_pzs","meta_pzs"])
    rows = leer_csv_dict(path)
    for r in rows:
        if r.get("fecha")==fecha_iso:
            r["oee_dia_%"]=f"{oee_pct:.2f}"; r["total_pzs"]=str(total)
            r["scrap_pzs"]=str(scrap); r["meta_pzs"]=str(meta); break
    else:
        rows.append({"fecha":fecha_iso,"oee_dia_%":f"{oee_pct:.2f}",
                     "total_pzs":str(total),"scrap_pzs":str(scrap),"meta_pzs":str(meta)})
    with open(path,"w",newline="",encoding="utf-8") as f:
        w=csv.DictWriter(f,fieldnames=["fecha","oee_dia_%","total_pzs","scrap_pzs","meta_pzs"])
        w.writeheader(); w.writerows(rows)

def fechas_registradas(path_daily):
    asegurar_csv(path_daily, ["fecha","oee_dia_%","total_pzs","scrap_pzs","meta_pzs"])
    return {r["fecha"] for r in leer_csv_dict(path_daily) if r.get("fecha")}

def asegurar_archivos_basicos():
    asegurar_csv(DAILY_CSV_GLOBAL, ["fecha","oee_dia_%","total_pzs","scrap_pzs","meta_pzs"])
    asegurar_csv(DAILY_CSV_INJECTOR, ["fecha","oee_dia_%","total_pzs","scrap_pzs","meta_pzs"])
    asegurar_csv(RECIPES_CSV, [
        "molde_id","parte","ciclo_ideal_s","cavidades","cavidades_habilitadas","scrap_esperado_pct","activo"
    ])
    if not leer_csv_dict(RECIPES_CSV):
        with open(RECIPES_CSV,"a",newline="",encoding="utf-8") as f:
            w=csv.writer(f)
            w.writerow(["48","19-001-049","45","1","1","2","1"])
            w.writerow(["84","19-001-084","23","1","1","2","1"])
    asegurar_csv(PLANNING_CSV, ["orden","parte","molde_id","maquina_id","qty_total","inicio_ts","fin_est_ts","setup_min","estado","ciclo_s","cav_on"])
    asegurar_csv(DELIV_CSV,    ["orden","due_date","qty","cumplido"])
    asegurar_csv(SHIPMENTS_CSV,["orden","ship_date","qty","destino","nota"])

def asegurar_archivos_maquina(machine):
    asegurar_csv(machine["oee_csv"], [
        "timestamp","fecha","operador","turno","molde","parte","ciclo_s","horas_turno",
        "tiempo_paro_min","meta_oper_pzs","total_pzs","scrap_pzs","buenas_pzs",
        "availability_%","performance_%","quality_%","oee_%"
    ])
    asegurar_csv(machine["down_csv"], [
        "fecha","inicio_ts","fin_ts","duracion_seg","motivo","nota","operador","turno","molde"
    ])

# ---------- c√°lculos ----------
def calcular_tiempos(horas_turno, ciclo_s, paro_seg):
    turno_seg = int(max(0, horas_turno or 0) * 3600)
    operativo = max(0, turno_seg - int(max(0, paro_seg or 0)))
    ciclo     = int(ciclo_s or 0)
    meta_plan = int(turno_seg // ciclo) if ciclo>0 else 0
    meta_oper = int(operativo // ciclo) if ciclo>0 else 0
    return turno_seg, operativo, meta_plan, meta_oper

def calcular_metricas(total, scrap, turno_seg, oper_seg, ciclo_ideal_s):
    total   = int(total or 0)
    scrap   = int(scrap or 0)
    buenas  = max(0, total - scrap)
    A = (oper_seg/turno_seg) if turno_seg>0 else 0.0
    A = max(0.0, min(1.0, A))
    perf_num = buenas * float(ciclo_ideal_s or 0)
    P = (perf_num/oper_seg) if oper_seg>0 else 0.0
    P = max(0.0, min(1.0, P))
    Q = (buenas/total) if total>0 else 0.0
    OEE = A * P * Q * 100.0
    return buenas, round(A*100,2), round(P*100,2), round(Q*100,2), round(OEE,2)

def parse_int_str(s, default=0):
    try:
        s = str(s).replace(",",".").strip()
        return int(float(s))
    except:
        return default

def acum_por_fecha(rows, fecha_iso):
    total=scrap=0; meta=0.0; n=0; turno_seg=0; paro_seg=0
    for r in rows:
        if r.get("fecha")!=fecha_iso: continue
        try:
            total+=int(float(r.get("total_pzs","0")))
            scrap+=int(float(r.get("scrap_pzs","0")))
            meta +=float(r.get("meta_oper_pzs","0"))
            horas=float(str(r.get("horas_turno","0")).replace(",",".")) or 0.0
            turno_seg += int(horas*3600)
            pmin=float(str(r.get("tiempo_paro_min","0")).replace(",",".")) or 0.0
            paro_seg  += int(pmin*60)
            n+=1
        except: pass
    buenas=max(0,total-scrap)
    oper_seg=max(0, turno_seg-paro_seg)
    if total<=0 or meta<=0 or turno_seg<=0 or oper_seg<=0:
        return {"count":n,"total":total,"scrap":scrap,"buenas":buenas,
                "avail_pct":0.0,"perf_pct":0.0,"qual_pct":0.0,"oee_pct":0.0,"meta_pzs":meta}
    A=oper_seg/turno_seg
    P=total/meta
    Q=buenas/total
    OEE=A*P*Q*100.0
    return {"count":n,"total":total,"scrap":scrap,"buenas":buenas,
            "avail_pct":round(A*100,2),"perf_pct":round(P*100,2),"qual_pct":round(Q*100,2),
            "oee_pct":round(OEE,2),"meta_pzs":meta}

def acum_global(rows):
    total=scrap=0; meta=0.0; n=0; dias=set(); turno_seg=0; paro_seg=0
    for r in rows:
        try:
            total+=int(float(r.get("total_pzs","0")))
            scrap+=int(float(r.get("scrap_pzs","0")))
            meta +=float(r.get("meta_oper_pzs","0"))
            horas=float(str(r.get("horas_turno","0")).replace(",",".")) or 0.0
            turno_seg += int(horas*3600)
            pmin=float(str(r.get("tiempo_paro_min","0")).replace(",",".")) or 0.0
            paro_seg  += int(pmin*60)
            n+=1
            if r.get("fecha"): dias.add(r["fecha"])
        except: pass
    buenas=max(0,total-scrap)
    oper_seg=max(0, turno_seg-paro_seg)
    if total<=0 or meta<=0 or turno_seg<=0 or oper_seg<=0:
        return {"registros":n,"dias":len(dias),"total":total,"scrap":scrap,
                "buenas":buenas,"avail_pct":0.0,"perf_pct":0.0,
                "qual_pct":0.0,"oee_pct":0.0,"meta_pzs":meta}
    A=oper_seg/turno_seg
    P=total/meta
    Q=buenas/total
    OEE=A*P*Q*100.0
    return {"registros":n,"dias":len(dias),"total":total,"scrap":scrap,"buenas":buenas,
            "avail_pct":round(A*100,2),"perf_pct":round(P*100,2),
            "qual_pct":round(Q*100,2),"oee_pct":round(OEE,2),"meta_pzs":meta}

def promedio_oee_daily(path_daily):
    vals=[float(r.get("oee_dia_%","0") or 0) for r in leer_csv_dict(path_daily)] if os.path.exists(path_daily) else []
    return round(sum(vals)/len(vals),2) if vals else 0.0

def dia_semana_es(f):
    try: y,m,d=map(int,f.split("-")); return DIAS_ES[date(y,m,d).weekday()]
    except: return "D√≠a"

def segs_to_hms_str(s):
    s=max(0,int(s)); h=s//3600; m=(s%3600)//60; sc=s%60; return f"{h:02d}:{m:02d}:{sc:02d}"

# ===== producidas por molde (para milestones/√≥rdenes) =====
def producido_por_molde_global(molde_id: str, hasta_fecha: str = None) -> int:
    total_buenas = 0
    for m in MACHINES:
        rows = leer_csv_dict(m["oee_csv"])
        for r in rows:
            try:
                if str(r.get("molde","")).strip() == str(molde_id).strip():
                    if hasta_fecha:
                        if (r.get("fecha") or "") <= hasta_fecha:
                            total_buenas += int(float(r.get("buenas_pzs","0")))
                    else:
                        total_buenas += int(float(r.get("buenas_pzs","0")))
            except: pass
    return total_buenas

def enviados_por_orden(orden: str) -> int:
    return sum(parse_int_str(r.get("qty","0")) for r in leer_csv_dict(SHIPMENTS_CSV) if r.get("orden")==orden)

# ===== resumen por m√°quina (hoy) con fallback robusto =====
def _safe_float(x, default=0.0):
    try: return float(str(x).replace(",",".")) if x not in (None,"") else default
    except: return default

def resumen_hoy_maquina(machine, fecha_iso):
    asegurar_archivos_maquina(machine)
    rows = [r for r in leer_csv_dict(machine["oee_csv"]) if r.get("fecha")==fecha_iso]
    if not rows:
        return dict(oee=0.0,A=0.0,P=0.0,Q=0.0,total=0,buenas=0,scrap=0,
                    meta=0, ciclo_ideal=0, ciclo_real=0.0,
                    turno_seg=0, oper_seg=0, ultimo_paro="-", oee_dia=0.0)
    total = sum(parse_int_str(r.get("total_pzs","0")) for r in rows)
    scrap = sum(parse_int_str(r.get("scrap_pzs","0")) for r in rows)
    buenas= max(0,total-scrap)
    horas_sum = sum(_safe_float(r.get("horas_turno","0")) for r in rows)
    turno_seg = int(horas_sum * 3600)
    paro_seg  = int(sum(_safe_float(r.get("tiempo_paro_min","0")) for r in rows) * 60)
    oper_seg  = max(0, turno_seg - paro_seg)
    ciclos = [parse_int_str(r.get("ciclo_s","0")) for r in rows if parse_int_str(r.get("ciclo_s","0"))>0]
    ciclo_ideal = ciclos[-1] if ciclos else 0
    if turno_seg>0 and ciclo_ideal>0:
        A = (oper_seg/turno_seg); P = ((buenas*ciclo_ideal)/oper_seg) if oper_seg>0 else 0.0; Q = (buenas/total) if total>0 else 0.0
        oee = A*P*Q*100.0; A*=100.0; P*=100.0; Q*=100.0
    else:
        A = sum(_safe_float(r.get("availability_%","0")) for r in rows) / max(1,len(rows))
        P = sum(_safe_float(r.get("performance_%","0")) for r in rows) / max(1,len(rows))
        Q = sum(_safe_float(r.get("quality_%","0")) for r in rows) / max(1,len(rows))
        oee = sum(_safe_float(r.get("oee_%","0")) for r in rows) / max(1,len(rows))
    meta_oper = int((oper_seg // ciclo_ideal) if ciclo_ideal>0 else 0)
    ciclo_real = (oper_seg/buenas) if buenas>0 else 0.0
    downs = [r for r in leer_csv_dict(machine["down_csv"]) if r.get("fecha")==fecha_iso]
    if downs:
        d = downs[-1]
        try:
            mins = round(int(float(d.get("duracion_seg","0")))/60.0,1)
            ultimo = f"{d.get('inicio_ts','')} -> {d.get('fin_ts','')}   {mins:.1f} min ({d.get('motivo','')})"
        except:
            ultimo = f"{d.get('inicio_ts','')} -> {d.get('fin_ts','')}   ({d.get('motivo','')})"
    else:
        ultimo="-"
    # === NUEVO: OEE acumulado del d√≠a (misma fuente que el √°rea)
    a = acum_por_fecha(leer_csv_dict(machine["oee_csv"]), fecha_iso)
    oee_dia = a["oee_pct"]
    return dict(oee=round(oee,2),A=round(A,2),P=round(P,2),Q=round(Q,2),
                total=total,buenas=buenas,scrap=scrap, meta=meta_oper,
                ciclo_ideal=ciclo_ideal, ciclo_real=round(ciclo_real,2),
                turno_seg=turno_seg, oper_seg=oper_seg, ultimo_paro=ultimo,
                oee_dia=round(oee_dia,2))

# ---------- Vistas ----------
class RecipesView(ctk.CTkFrame):
    """Gestor de Recetas (molde/parte/ciclo...)"""
    def __init__(self, master, app):
        super().__init__(master, fg_color="transparent")
        self.app=app
        self._build()
    def _build(self):
        header=ctk.CTkFrame(self, corner_radius=0, fg_color=("white","#111111"))
        header.pack(fill="x", side="top")
        left=ctk.CTkFrame(header, fg_color="transparent"); left.pack(side="left", padx=16, pady=10)
        ctk.CTkButton(left, text="‚Üê Men√∫", command=self.app.go_menu, width=100, corner_radius=10,
                      fg_color="#E5E7EB", text_color="#111", hover_color="#D1D5DB").pack(side="left", padx=(0,10))
        ctk.CTkLabel(left, text="Recetas ‚Äî Moldes/Partes", font=ctk.CTkFont("Helvetica", 20, "bold")).pack(side="left")
        body=ctk.CTkFrame(self, fg_color="transparent"); body.pack(fill="both", expand=True, padx=16, pady=16)
        table_card=ctk.CTkFrame(body, corner_radius=18); table_card.pack(side="left", fill="both", expand=True, padx=(0,10))
        ctk.CTkLabel(table_card, text="Recetas", font=ctk.CTkFont("Helvetica",13,"bold")).pack(anchor="w", padx=8, pady=(8,0))
        ctk.CTkFrame(table_card, height=1, fg_color=("#E5E7EB","#2B2B2B")).pack(fill="x", padx=8, pady=(6,8))
        cols=("molde_id","parte","ciclo_ideal_s","cavidades","cavidades_habilitadas","scrap_esperado_pct","activo")
        self.tree=ttk.Treeview(table_card, columns=cols, show="headings", height=12)
        heads=[("molde_id","Molde",90),("parte","# Parte",140),("ciclo_ideal_s","Ciclo (s)",90),
               ("cavidades","Cav.",70),("cavidades_habilitadas","Cav. ON",80),
               ("scrap_esperado_pct","Scrap %",80),("activo","Activo",70)]
        for key,txt,w in heads:
            self.tree.heading(key, text=txt); self.tree.column(key, width=w, anchor="center")
        self.tree.pack(fill="both", expand=True, padx=8, pady=(0,8))
        self.tree.bind("<<TreeviewSelect>>", self._on_select)
        btnbar=ctk.CTkFrame(table_card, fg_color="transparent"); btnbar.pack(fill="x", padx=8, pady=(0,10))
        ctk.CTkButton(btnbar, text="Nuevo", command=self._new).pack(side="left", padx=(0,8))
        ctk.CTkButton(btnbar, text="Guardar", command=self._save).pack(side="left", padx=8)
        ctk.CTkButton(btnbar, text="Eliminar", fg_color="#ef4444", hover_color="#dc2626", command=self._delete).pack(side="left", padx=8)
        ctk.CTkButton(btnbar, text="‚Üª Recargar", fg_color="#E5E7EB", text_color="#111", hover_color="#D1D5DB", command=self._load).pack(side="left", padx=8)
        ctk.CTkButton(btnbar, text="Ir a OEE", command=self.app.go_oee_select_machine).pack(side="right")
        form=ctk.CTkFrame(body, corner_radius=18); form.pack(side="left", fill="both", expand=False, padx=(10,0))
        ctk.CTkLabel(form, text="Editar receta", font=ctk.CTkFont("Helvetica",13,"bold")).pack(anchor="w", padx=8, pady=(8,0))
        ctk.CTkFrame(form, height=1, fg_color=("#E5E7EB","#2B2B2B")).pack(fill="x", padx=8, pady=(6,8))
        def frow(lbl, var, width=160, typ="entry"):
            r=ctk.CTkFrame(form, fg_color="transparent"); r.pack(fill="x", padx=8, pady=4)
            ctk.CTkLabel(r, text=lbl).pack(side="left")
            if typ=="entry":
                e=ctk.CTkEntry(r, width=width, textvariable=var, justify="center"); e.pack(side="right"); return e
            else:
                om=ctk.CTkOptionMenu(r, values=["0","1"], variable=var); om.pack(side="right"); return om
        self.var_molde = tk.StringVar()           # <<< mantener como string para no romper IDs alfanum√©ricos
        self.var_parte = tk.StringVar()
        self.var_ciclo = tk.StringVar()
        self.var_cavs  = tk.StringVar()
        self.var_cavs_on = tk.StringVar()
        self.var_scrap = tk.StringVar()
        self.var_activo= tk.StringVar(value="1")
        frow("Molde ID", self.var_molde)
        frow("# Parte", self.var_parte)
        frow("Ciclo ideal (s)", self.var_ciclo)
        frow("Cavidades", self.var_cavs)
        frow("Cavidades habilitadas", self.var_cavs_on)
        frow("Scrap esperado (%)", self.var_scrap)
        frow("Activo (1/0)", self.var_activo, typ="om")
        self._load()
    def _load(self):
        for i in self.tree.get_children(): self.tree.delete(i)
        for r in leer_csv_dict(RECIPES_CSV):
            self.tree.insert("", "end", values=(r["molde_id"], r["parte"], r["ciclo_ideal_s"],
                                                r["cavidades"], r["cavidades_habilitadas"],
                                                r["scrap_esperado_pct"], r["activo"]))
        self.app._refresh_moldes_from_recipes()
    def _on_select(self, *_):
        sel=self.tree.selection()
        if not sel: return
        vals=self.tree.item(sel[0],"values")
        (self.var_molde.set(vals[0]), self.var_parte.set(vals[1]), self.var_ciclo.set(vals[2]),
         self.var_cavs.set(vals[3]), self.var_cavs_on.set(vals[4]), self.var_scrap.set(vals[5]),
         self.var_activo.set(vals[6]))
    def _new(self):
        self.var_molde.set(""); self.var_parte.set(""); self.var_ciclo.set("")
        self.var_cavs.set(""); self.var_cavs_on.set(""); self.var_scrap.set(""); self.var_activo.set("1")
    def _save(self):
        m=self.var_molde.get().strip()
        if not (m and self.var_ciclo.get().strip()):
            messagebox.showwarning("Faltan datos","Molde y ciclo ideal son obligatorios."); return
        rows=leer_csv_dict(RECIPES_CSV); found=False
        for r in rows:
            if r["molde_id"]==m:
                r.update({
                    "parte": self.var_parte.get().strip(),
                    "ciclo_ideal_s": self.var_ciclo.get().strip(),
                    "cavidades": self.var_cavs.get().strip(),
                    "cavidades_habilitadas": self.var_cavs_on.get().strip(),
                    "scrap_esperado_pct": self.var_scrap.get().strip(),
                    "activo": self.var_activo.get().strip() or "1"
                })
                found=True; break
        if not found:
            rows.append({
                "molde_id": m,
                "parte": self.var_parte.get().strip(),
                "ciclo_ideal_s": self.var_ciclo.get().strip(),
                "cavidades": self.var_cavs.get().strip(),
                "cavidades_habilitadas": self.var_cavs_on.get().strip(),
                "scrap_esperado_pct": self.var_scrap.get().strip(),
                "activo": self.var_activo.get().strip() or "1"
            })
        with open(RECIPES_CSV,"w",newline="",encoding="utf-8") as f:
            w=csv.DictWriter(f, fieldnames=["molde_id","parte","ciclo_ideal_s",
                                            "cavidades","cavidades_habilitadas","scrap_esperado_pct","activo"])
            w.writeheader(); w.writerows(rows)
        self._load(); messagebox.showinfo("Recetas","Receta guardada.")
        self.app._refresh_moldes_from_recipes()
        try:
            self.app._on_molde_change(); self.app._update_now()
        except: pass
    def _delete(self):
        sel=self.tree.selection()
        if not sel: return
        molde = self.tree.item(sel[0],"values")[0]
        if not messagebox.askyesno("Eliminar","¬øEliminar la receta del molde "+str(molde)+"?"): return
        rows=[r for r in leer_csv_dict(RECIPES_CSV) if r["molde_id"]!=molde]
        with open(RECIPES_CSV,"w",newline="",encoding="utf-8") as f:
            w=csv.DictWriter(f, fieldnames=["molde_id","parte","ciclo_ideal_s",
                                            "cavidades","cavidades_habilitadas","scrap_esperado_pct","activo"])
            w.writeheader(); w.writerows(rows)
        self._load(); self.app._refresh_moldes_from_recipes()
        try:
            self.app._on_molde_change(); self.app._update_now()
        except: pass

class MachineChooser(ctk.CTkFrame):
    def __init__(self, master, app):
        super().__init__(master, fg_color="transparent")
        self.app=app
        box=ctk.CTkFrame(self, corner_radius=20); box.pack(expand=True, fill="both", padx=40, pady=40)
        ctk.CTkLabel(box, text="Selecciona m√°quina", font=ctk.CTkFont("Helvetica",26,"bold")).pack(pady=(18,8))
        grid=ctk.CTkFrame(box, fg_color="transparent"); grid.pack(pady=10)
        for i, m in enumerate(MACHINES):
            ctk.CTkButton(grid, text=m["name"], height=56, corner_radius=16,
                          command=lambda mm=m: self.app.go_oee(mm)).grid(row=i, column=0, pady=8, padx=8, sticky="ew")
        ctk.CTkButton(box, text="‚Üê Volver al men√∫", height=44, corner_radius=12,
                      fg_color="#E5E7EB", text_color="#111", hover_color="#D1D5DB",
                      command=self.app.go_menu).pack(pady=(18,0))

class OEEView(ctk.CTkFrame):
    def __init__(self, master, app, machine):
        super().__init__(master, fg_color="transparent")
        self.app=app; self.machine=machine
        self._build_header(); self._build_body()
    def _build_header(self):
        header=ctk.CTkFrame(self, corner_radius=0, fg_color=("white","#111111")); header.pack(fill="x", side="top")
        left=ctk.CTkFrame(header, fg_color="transparent"); left.pack(side="left", padx=16, pady=10)
        ctk.CTkButton(left, text="‚Üê Elegir m√°quina", command=self.app.go_oee_select_machine, width=140, corner_radius=10,
                      fg_color="#E5E7EB", text_color="#111", hover_color="#D1D5DB").pack(side="left", padx=(0,10))
        ctk.CTkLabel(left, text=f"OEE ‚Äî Registro de Producci√≥n ({self.machine['name']})",
                     font=ctk.CTkFont("Helvetica", 20, "bold")).pack(side="left")
        right=ctk.CTkFrame(header, fg_color="transparent"); right.pack(side="right", padx=16, pady=10)
        self.clock_lbl = ctk.CTkLabel(right, text="", font=ctk.CTkFont("Helvetica",13)); self.clock_lbl.pack(side="right", padx=(8,0))
        theme = ctk.CTkSegmentedButton(right, values=["Claro","Oscuro"],
                                       command=lambda v: ctk.set_appearance_mode("dark" if v=="Oscuro" else "light"))
        theme.set("Claro"); theme.pack(side="right", padx=10)
        try:
            img=Image.open(LOGO_PATH); logo=ctk.CTkImage(light_image=img, dark_image=img, size=(120,48))
            ctk.CTkLabel(right, image=logo, text="").pack(side="right", padx=10); self.logo=logo
        except: pass
    def _build_body(self):
        body=ctk.CTkFrame(self, fg_color="transparent"); body.pack(fill="both", expand=True, padx=16, pady=16)
        body.grid_rowconfigure(0, weight=1); body.grid_columnconfigure(0, weight=1); body.grid_columnconfigure(1, weight=1)
        # izquierda
        left=ctk.CTkScrollableFrame(body, corner_radius=18); left.grid(row=0, column=0, sticky="nsew", padx=(0,10))
        # Fecha
        sec=self._sec(left,"Fecha"); sec.pack(fill="x", padx=14, pady=(14,8))
        row=ctk.CTkFrame(sec, fg_color="transparent"); row.pack(fill="x")
        ctk.CTkLabel(row, text="YYYY-MM-DD").pack(side="left")
        ctk.CTkEntry(row, width=140, textvariable=self.app.fecha_sel, justify="center").pack(side="left", padx=8)
        ctk.CTkButton(row, text="Usar", command=self.app._on_fecha_change).pack(side="left", padx=8)
        ctk.CTkButton(row, text="üìÖ", width=40, command=self.app._open_calendar).pack(side="left", padx=6)
        self.lbl_dia=ctk.CTkLabel(sec, text="", font=ctk.CTkFont("Helvetica", 12, "bold")); self.lbl_dia.pack(anchor="w", pady=(6,0))
        self.app.lbl_dia=self.lbl_dia
        # Operador
        sec=self._sec(left,"Operador"); sec.pack(fill="x", padx=14, pady=8)
        op=ctk.CTkOptionMenu(sec, values=["Selecciona"]+[o.capitalize() for o in OPERADORES],
                             command=lambda v: self.app._set_operador(v.lower()) if v!="Selecciona" else None)
        op.set("Selecciona"); op.pack(fill="x", padx=4, pady=4)
        # Turno
        sec=self._sec(left,"Turno"); sec.pack(fill="x", padx=14, pady=8)
        tu=ctk.CTkOptionMenu(sec, values=["Selecciona","1","2","3"],
                             command=lambda v: self.app._set_turno(v) if v.isdigit() else None)
        tu.set("Selecciona"); tu.pack(fill="x", padx=4, pady=4)
        # Molde / Receta
        sec=self._sec(left,"Molde / Receta"); sec.pack(fill="x", padx=14, pady=8)
        valores_moldes = ["Selecciona"] + sorted([k for k in self.app.recipe_map.keys()])
        self.molde_menu = ctk.CTkOptionMenu(sec, values=valores_moldes, command=self.app._set_molde)
        self.molde_menu.pack(fill="x", padx=4, pady=4)
        info = ctk.CTkFrame(sec, fg_color="transparent"); info.pack(fill="x", pady=(6,0))
        ctk.CTkLabel(info, text="Ciclo ideal (s):").grid(row=0, column=0, sticky="w", padx=(0,6))
        ctk.CTkLabel(info, textvariable=self.app.ciclo_s, font=ctk.CTkFont("Helvetica",12,"bold")).grid(row=0, column=1, sticky="w")
        ctk.CTkLabel(info, text="# Parte:").grid(row=1, column=0, sticky="w", padx=(0,6), pady=(4,0))
        self.lbl_parte = ctk.CTkLabel(info, text="", font=ctk.CTkFont("Helvetica",12,"bold")); self.lbl_parte.grid(row=1, column=1, sticky="w", pady=(4,0))
        ctk.CTkLabel(info, text="Cavidades (ON/Tot):").grid(row=2, column=0, sticky="w", padx=(0,6), pady=(4,0))
        self.lbl_cavs = ctk.CTkLabel(info, text="", font=ctk.CTkFont("Helvetica",12,"bold")); self.lbl_cavs.grid(row=2, column=1, sticky="w", pady=(4,0))
        self.app.lbl_parte = self.lbl_parte; self.app.lbl_cavs  = self.lbl_cavs
        # Producci√≥n
        sec=self._sec(left,"Producci√≥n (turno)"); sec.pack(fill="x", padx=14, pady=8)
        self._counter(sec,"Total",self.app.total); self._counter(sec,"Scrap",self.app.scrap)
        actions=ctk.CTkFrame(sec, fg_color="transparent"); actions.pack(fill="x", pady=(10,0))
        self.btn_guardar=ctk.CTkButton(actions, text="Guardar (Ctrl+Enter)", corner_radius=12, command=self.app._guardar)
        self.btn_guardar.pack(side="left", expand=True, fill="x", padx=(0,6))
        ctk.CTkButton(actions, text="Reset contadores", corner_radius=12, fg_color="#E5E7EB",
                      text_color="#111", hover_color="#D1D5DB", command=self.app._reset_contadores)\
            .pack(side="left", expand=True, fill="x", padx=(6,0))
        self.app.btn_guardar=self.btn_guardar
        # Paros
        sec=self._sec(left,"Paros (cron√≥metro)"); sec.pack(fill="x", padx=14, pady=8)
        picker=ctk.CTkFrame(sec, fg_color="transparent"); picker.pack(fill="x", pady=(0,8))
        ctk.CTkLabel(picker, text="Motivo").pack(side="left")
        self.motivo_menu = ctk.CTkOptionMenu(picker, values=MOTIVOS_PARO); self.motivo_menu.pack(side="left", padx=8)
        ctk.CTkLabel(picker, text="Nota").pack(side="left", padx=(12,0))
        self.nota_entry=ctk.CTkEntry(picker, width=220, placeholder_text="opcional"); self.nota_entry.pack(side="left", padx=8)
        r1=ctk.CTkFrame(sec, fg_color="transparent"); r1.pack(fill="x", pady=(2,2))
        ctk.CTkLabel(r1, text="Paro actual").pack(side="left")
        self.lbl_paro_actual=ctk.CTkLabel(r1, text="00:00:00", font=ctk.CTkFont("Helvetica",16,"bold")); self.lbl_paro_actual.pack(side="right")
        r2=ctk.CTkFrame(sec, fg_color="transparent"); r2.pack(fill="x", pady=(2,8))
        ctk.CTkLabel(r2, text="Paro acumulado (turno)").pack(side="left")
        self.lbl_paro_acum=ctk.CTkLabel(r2, text="00:00:00", font=ctk.CTkFont("Helvetica",16,"bold")); self.lbl_paro_acum.pack(side="right")
        rbtn=ctk.CTkFrame(sec, fg_color="transparent"); rbtn.pack(fill="x", pady=(0,8))
        self.btn_toggle_paro=ctk.CTkButton(rbtn, text="Iniciar paro", height=44, corner_radius=14,
                                           command=self.app.toggle_paro, fg_color="#ef4444", hover_color="#dc2626")
        self.btn_toggle_paro.pack(side="left", expand=True, fill="x", padx=(0,8))
        ctk.CTkButton(rbtn, text="Reset paros", height=44, corner_radius=14, fg_color="#E5E7EB",
                      text_color="#111", hover_color="#D1D5DB", command=self.app.reset_paros)\
            .pack(side="left", expand=True, fill="x", padx=(8,0))
        # bit√°cora
        table_card=ctk.CTkFrame(sec, corner_radius=10); table_card.pack(fill="both", expand=True, pady=(10,0))
        cols=("inicio","fin","motivo","nota","dur_min")
        self.tree=ttk.Treeview(table_card, columns=cols, show="headings", height=6)
        for c, txt, w, anchor in [("inicio","Inicio",135,"center"),("fin","Fin",135,"center"),
                                  ("motivo","Motivo",160,"w"),("nota","Nota",220,"w"),("dur_min","Dur (min)",80,"e")]:
            self.tree.heading(c, text=txt); self.tree.column(c, width=w, anchor=anchor)
        self.tree.pack(fill="both", expand=True, padx=8, pady=8)
        style=ttk.Style(); style.configure("Treeview", rowheight=24, font=("Helvetica",10))
        style.configure("Treeview.Heading", font=("Helvetica",10,"bold"))
        # derecha
        right=ctk.CTkFrame(body, corner_radius=18); right.grid(row=0, column=1, sticky="nsew", padx=(10,0))
        sec=self._sec(right,"Metas"); sec.pack(fill="x", padx=14, pady=(14,8))
        r=ctk.CTkFrame(sec, fg_color="transparent"); r.pack(fill="x")
        ctk.CTkLabel(r, text="Meta planificada (pzs)").pack(side="left")
        self.meta_plan_val=ctk.CTkLabel(r, text="0", font=ctk.CTkFont("Helvetica",16,"bold")); self.meta_plan_val.pack(side="left", padx=6)
        r=ctk.CTkFrame(sec, fg_color="transparent"); r.pack(fill="x", pady=(6,0))
        ctk.CTkLabel(r, text="Meta operativa (pzs)").pack(side="left")
        self.meta_oper_val=ctk.CTkLabel(r, text="0", font=ctk.CTkFont("Helvetica",16,"bold")); self.meta_oper_val.pack(side="left", padx=6)
        bars=ctk.CTkFrame(right, fg_color="transparent"); bars.pack(fill="x", padx=14, pady=8)
        ctk.CTkLabel(bars, text="Disponibilidad").pack(anchor="w")
        self.pb_avail=ctk.CTkProgressBar(bars); self.pb_avail.set(0.0); self.pb_avail.pack(fill="x", pady=(2,8))
        ctk.CTkLabel(bars, text="Avance a meta (operativa)").pack(anchor="w")
        self.pb_meta=ctk.CTkProgressBar(bars); self.pb_meta.set(0.0); self.pb_meta.pack(fill="x", pady=(2,8))
        ctk.CTkLabel(bars, text="Calidad (Buenas / Total)").pack(anchor="w")
        self.pb_quality=ctk.CTkProgressBar(bars); self.pb_quality.set(0.0); self.pb_quality.pack(fill="x", pady=(2,8))
        sec=self._sec(right,"Tiempo real (turno)"); sec.pack(fill="x", padx=14, pady=8)
        self._metric(sec,"Availability (RT)",self.app.avail_rt)
        self._metric(sec,"Performance (RT)",self.app.perf_rt)
        self._metric(sec,"Quality (RT)",self.app.qual_rt)
        self._metric(sec,"OEE (RT)",self.app.oee_rt)
        sec=self._sec(right,"D√≠a seleccionado (acumulado)"); sec.pack(fill="x", padx=14, pady=8)
        self._metric(sec,"Total d√≠a",self.app.tot_day)
        self._metric(sec,"Scrap d√≠a",self.app.scr_day)
        self._metric(sec,"Buenas d√≠a",self.app.buen_day)
        self._metric(sec,"Performance d√≠a",self.app.perf_day)
        self._metric(sec,"Quality d√≠a",self.app.qual_day)
        self._metric(sec,"OEE d√≠a",self.app.oee_day)
        ctk.CTkLabel(sec, textvariable=self.app.day_info, text_color=("#6b7280","#9CA3AF")).pack(anchor="w", pady=(6,0))
        sec=self._sec(right,"Hist√≥rico (promedio OEE d√≠a)"); sec.pack(fill="x", padx=14, pady=8)
        self._metric(sec,"OEE hist√≥rico",self.app.oee_hist)
        sec=self._sec(right,"Global (todos los registros)"); sec.pack(fill="x", padx=14, pady=(8,14))
        self._metric(sec,"Total global",self.app.glob_total)
        self._metric(sec,"Scrap global",self.app.glob_scrap)
        self._metric(sec,"Buenas global",self.app.glob_buenas)
        self._metric(sec,"Performance global",self.app.glob_perf)
        self._metric(sec,"Quality global",self.app.glob_qual)
        self._metric(sec,"OEE global",self.app.glob_oee)
        ctk.CTkLabel(sec, textvariable=self.app.glob_info, text_color=("#6b7280","#9CA3AF")).pack(anchor="w", pady=(6,0))
        self.app.meta_plan_val=self.meta_plan_val; self.app.meta_oper_val=self.meta_oper_val
        self.app.pb_avail=self.pb_avail; self.app.pb_meta=self.pb_meta; self.app.pb_quality=self.pb_quality
        self.app.lbl_paro_actual=self.lbl_paro_actual; self.app.lbl_paro_acum=self.lbl_paro_acum
        self.app.btn_toggle_paro=self.btn_toggle_paro
        self.app.motivo_menu=self.motivo_menu; self.app.nota_entry=self.nota_entry; self.app.tree=self.tree
        self.app.molde_menu=self.molde_menu
        self.app._clock_label = self.clock_lbl
    # helpers UI
    def _sec(self, parent, title):
        card=ctk.CTkFrame(parent, corner_radius=16)
        ctk.CTkLabel(card, text=title, font=ctk.CTkFont("Helvetica",13,"bold")).pack(anchor="w", padx=8, pady=(8,0))
        ctk.CTkFrame(card, height=1, fg_color=("#E5E7EB","#2B2B2B")).pack(fill="x", padx=8, pady=(6,8))
        return card
    def _counter(self, parent, label, var):
        r=ctk.CTkFrame(parent, fg_color="transparent"); r.pack(fill="x", pady=6)
        ctk.CTkLabel(r, text=label).pack(side="left")
        e=ctk.CTkEntry(r, width=140, textvariable=var, justify="center"); e.pack(side="left", padx=8)
        ctk.CTkButton(r, text="-", width=44, height=40, command=lambda: self.app._nudge(var,-1), corner_radius=14).pack(side="left", padx=4)
        ctk.CTkButton(r, text="+", width=44, height=40, command=lambda: self.app._nudge(var,+1), corner_radius=14).pack(side="left", padx=4)
        e.bind("<FocusOut>", lambda ev: self.app._sanitize(var)); e.bind("<Return>", lambda ev: self.app._sanitize(var))
    def _metric(self, parent, label, var):
        r=ctk.CTkFrame(parent, fg_color="transparent"); r.pack(fill="x", pady=4)
        ctk.CTkLabel(r, text=label).pack(side="left")
        ctk.CTkLabel(r, textvariable=var, font=ctk.CTkFont("Helvetica",16,"bold")).pack(side="right")

# ===== TABLERO EN VIVO (mejorado) =====
class LiveDashboard(ctk.CTkFrame):
    def __init__(self, master, app):
        super().__init__(master, fg_color="transparent")
        self.app = app
        self._timer = None
        self._build()

    def _tone(self, oee):
        if oee >= 85: return ("#DCFCE7", "#065F46")
        if oee >= 60: return ("#FEF9C3", "#92400E")
        return ("#FEE2E2", "#991B1B")

    def _build(self):
        header = ctk.CTkFrame(self, corner_radius=0, fg_color=("white","#111111"))
        header.pack(fill="x", side="top")
        left = ctk.CTkFrame(header, fg_color="transparent"); left.pack(side="left", padx=16, pady=10)
        ctk.CTkButton(left, text="‚Üê Men√∫", command=self.app.go_menu, width=110, corner_radius=10,
                      fg_color="#E5E7EB", text_color="#111", hover_color="#D1D5DB").pack(side="left", padx=(0,10))
        ctk.CTkLabel(left, text="Tablero en vivo ‚Äî √Årea de Inyecci√≥n",
                     font=ctk.CTkFont("Helvetica", 20, "bold")).pack(side="left")

        right = ctk.CTkFrame(header, fg_color="transparent"); right.pack(side="right", padx=16, pady=10)
        self.clock_lbl = ctk.CTkLabel(right, text="", font=ctk.CTkFont("Helvetica",13))
        self.clock_lbl.pack(side="right", padx=(8,0))
        ctk.CTkButton(right, text="Actualizar", command=self._refresh_now, width=110)\
            .pack(side="right", padx=(0,8))
        try:
            img=Image.open(LOGO_PATH); logo=ctk.CTkImage(light_image=img, dark_image=img, size=(120,48))
            ctk.CTkLabel(right, image=logo, text="").pack(side="right", padx=10); self.logo=logo
        except: pass

        body = ctk.CTkFrame(self, fg_color="transparent"); body.pack(fill="both", expand=True, padx=16, pady=16)
        body.grid_columnconfigure(0, weight=1); body.grid_columnconfigure(1, weight=1); body.grid_rowconfigure(1, weight=1)

        # Top: OEE √Årea
        self.card_area = ctk.CTkFrame(body, corner_radius=18)
        self.card_area.grid(row=0, column=0, columnspan=2, sticky="ew", padx=6, pady=(0,12))
        ctk.CTkLabel(self.card_area, text="OEE √Årea (hoy)", font=ctk.CTkFont("Helvetica", 16, "bold"))\
            .pack(anchor="w", padx=12, pady=(10,0))
        self.lbl_area = ctk.CTkLabel(self.card_area, text="0.00 %", font=ctk.CTkFont("Helvetica", 28, "bold"))
        self.lbl_area.pack(anchor="w", padx=12, pady=(4,12))

        # Cards por m√°quina
        self.cards = {}
        for i, m in enumerate(MACHINES):
            card = ctk.CTkFrame(body, corner_radius=18)
            card.grid(row=1, column=i, sticky="nsew", padx=6, pady=6)
            ctk.CTkLabel(card, text=m["name"], font=ctk.CTkFont("Helvetica", 15, "bold"))\
                .pack(anchor="w", padx=12, pady=(10,6))
            row1 = ctk.CTkFrame(card, fg_color="transparent"); row1.pack(fill="x", padx=12)

            self.cards[m["id"]] = {
                "wrap": card,
                "oee": ctk.CTkLabel(row1, text="OEE (RT) 0.00%", font=ctk.CTkFont("Helvetica",16,"bold")),
                "A":   ctk.CTkLabel(row1, text="A 0.00%", font=ctk.CTkFont("Helvetica",13)),
                "P":   ctk.CTkLabel(row1, text="P 0.00%", font=ctk.CTkFont("Helvetica",13)),
                "Q":   ctk.CTkLabel(row1, text="Q 0.00%", font=ctk.CTkFont("Helvetica",13)),
                "dia": ctk.CTkLabel(card, text="OEE d√≠a: 0.00%", font=ctk.CTkFont("Helvetica",13))
            }
            self.cards[m["id"]]["oee"].pack(side="left")
            self.cards[m["id"]]["A"].pack(side="left", padx=(12,0))
            self.cards[m["id"]]["P"].pack(side="left", padx=(12,0))
            self.cards[m["id"]]["Q"].pack(side="left", padx=(12,0))
            self.cards[m["id"]]["dia"].pack(anchor="w", padx=12, pady=(6,0))
            self.cards[m["id"]]["paro"]= ctk.CTkLabel(card, text="√öltimo paro: -", wraplength=520, justify="left")
            self.cards[m["id"]]["paro"].pack(anchor="w", padx=12, pady=(8,10))

        # Panel de gr√°ficas
        charts = ctk.CTkFrame(self, corner_radius=18)
        charts.pack(fill="x", padx=16, pady=(0,16))
        ctk.CTkLabel(charts, text="Estad√≠stica r√°pida", font=ctk.CTkFont("Helvetica", 14, "bold"))\
            .pack(anchor="w", padx=12, pady=(10,6))
        self.chart_area_frame = ctk.CTkFrame(charts, corner_radius=12); self.chart_area_frame.pack(fill="x", padx=12, pady=(0,12))
        self.chart_today_frame= ctk.CTkFrame(charts, corner_radius=12); self.chart_today_frame.pack(fill="x", padx=12, pady=(0,12))

        self._refresh_now()

    def _last7_area(self):
        out=[]; today=date.today()
        for i in range(6,-1,-1):
            f=(today - timedelta(days=i)).isoformat()
            vals=[]
            for m in MACHINES:
                a=acum_por_fecha(leer_csv_dict(m["oee_csv"]), f)
                if a["total"]>0 and a["meta_pzs"]>0: vals.append(a["oee_pct"])
            oee = (sum(vals)/len(vals)) if vals else 0.0
            out.append((f,oee))
        return out

    def _draw_mini_charts(self):
        # limpia
        for fr in (self.chart_area_frame, self.chart_today_frame):
            for w in fr.winfo_children(): w.destroy()

        sns.set_theme(style="whitegrid")

        # 7 d√≠as OEE √Årea (l√≠nea + relleno + labels)
        data=self._last7_area()
        if data:
            df=pd.DataFrame(data, columns=["fecha","oee"])
            fig, ax = plt.subplots(figsize=(7.5,2.6), dpi=120)
            sns.lineplot(ax=ax, data=df, x="fecha", y="oee", marker="o")
            ax.fill_between(df["fecha"], df["oee"], 0, alpha=0.15)
            for x, y in zip(df["fecha"], df["oee"]):
                ax.text(x, y+2, f"{y:.0f}%", ha="center", va="bottom", fontsize=8)
            ax.set_ylim(0,100); ax.set_ylabel("OEE %"); ax.set_xlabel(""); ax.grid(True, alpha=0.25)
            canvas=FigureCanvasTkAgg(fig, master=self.chart_area_frame)
            canvas.draw(); canvas.get_tk_widget().pack(fill="x", padx=8, pady=8); plt.close(fig)

        # Buenas vs Scrap (hoy) ‚Äî barras anotadas
        hoy=date.today().isoformat()
        good=bad=0
        for m in MACHINES:
            a=acum_por_fecha(leer_csv_dict(m["oee_csv"]), hoy); good+=a["buenas"]; bad+=a["scrap"]
        df2=pd.DataFrame({"tipo":["Buenas","Scrap"],"pzs":[good,bad]})
        fig2, ax2 = plt.subplots(figsize=(5.8,2.6), dpi=120)
        sns.barplot(ax=ax2, data=df2, x="tipo", y="pzs")
        for p in ax2.patches:
            ax2.annotate(f"{int(p.get_height())}", (p.get_x()+p.get_width()/2, p.get_height()),
                         ha="center", va="bottom", fontsize=9, xytext=(0,3), textcoords="offset points")
        ax2.set_xlabel(""); ax2.set_ylabel("Piezas"); ax2.grid(True, axis="y", alpha=0.25)
        canvas2=FigureCanvasTkAgg(fig2, master=self.chart_today_frame)
        canvas2.draw(); canvas2.get_tk_widget().pack(fill="x", padx=8, pady=8); plt.close(fig2)

        # Producci√≥n buenas por m√°quina (hoy)
        goods=[]
        for m in MACHINES:
            a=acum_por_fecha(leer_csv_dict(m["oee_csv"]), hoy)
            goods.append({"maquina":m["name"], "buenas":a["buenas"]})
        df3=pd.DataFrame(goods)
        fig3, ax3 = plt.subplots(figsize=(5.8,2.6), dpi=120)
        sns.barplot(ax=ax3, data=df3, x="maquina", y="buenas")
        for p in ax3.patches:
            ax3.annotate(f"{int(p.get_height())}", (p.get_x()+p.get_width()/2, p.get_height()),
                         ha="center", va="bottom", fontsize=9, xytext=(0,3), textcoords="offset points")
        ax3.set_xlabel(""); ax3.set_ylabel("Buenas"); ax3.grid(True, axis="y", alpha=0.25)
        canvas3=FigureCanvasTkAgg(fig3, master=self.chart_today_frame)
        canvas3.draw(); canvas3.get_tk_widget().pack(fill="x", padx=8, pady=8); plt.close(fig3)

    def _refresh_now(self):
        self.clock_lbl.configure(text=datetime.now().strftime("%d/%m/%Y %H:%M:%S"))
        hoy = date.today().isoformat()

        # OEE √Årea
        oees=[]
        for m in MACHINES:
            a = acum_por_fecha(leer_csv_dict(m["oee_csv"]), hoy)
            if a["total"]>0 and a["meta_pzs"]>0: oees.append(a["oee_pct"])
        area = (sum(oees)/len(oees)) if oees else 0.0
        self.lbl_area.configure(text=f"{area:.2f} %")

        # por m√°quina (RT + d√≠a)
        for m in MACHINES:
            r = resumen_hoy_maquina(m, hoy)
            card = self.cards[m["id"]]
            card["oee"].configure(text=f"OEE (RT) {r['oee']:.2f}%")
            card["A"].configure(text=f"A {r['A']:.2f}%")
            card["P"].configure(text=f"P {r['P']:.2f}%")
            card["Q"].configure(text=f"Q {r['Q']:.2f}%")
            card["dia"].configure(text=f"OEE d√≠a: {r['oee_dia']:.2f}%")
            card["paro"].configure(text=f"√öltimo paro: {r['ultimo_paro']}")
            bg, _ = self._tone(r["oee_dia"])
            try: card["wrap"].configure(fg_color=bg)
            except: pass

        self._draw_mini_charts()
        if self._timer: self.after_cancel(self._timer)
        self._timer = self.after(DASH_REFRESH_MS, self._refresh_now)

# ---------- Men√∫ ----------
class MainMenu(ctk.CTkFrame):
    def __init__(self, master, app):
        super().__init__(master, fg_color="transparent")
        box=ctk.CTkFrame(self, corner_radius=20); box.pack(expand=True, fill="both", padx=40, pady=40)
        try:
            img=Image.open(LOGO_PATH); logo=ctk.CTkImage(light_image=img, dark_image=img, size=(240,96))
            ctk.CTkLabel(box, image=logo, text="").pack(pady=(30,10)); self.logo=logo
        except:
            ctk.CTkLabel(box, text="MEFRUP", font=ctk.CTkFont("Helvetica",36,"bold")).pack(pady=(50,10))
        ctk.CTkLabel(box, text="Mefrup MLS", font=ctk.CTkFont("Helvetica",28,"bold")).pack(pady=(0,6))
        ctk.CTkLabel(box, text="Sistema de Monitoreo y Producci√≥n", font=ctk.CTkFont("Helvetica",14)).pack(pady=(0,20))
        ctk.CTkButton(box, text="Tablero en vivo (√Årea Inyecci√≥n)", height=48, corner_radius=14,
                      command=app.go_dashboard).pack(pady=(0,12), ipadx=20)
        ctk.CTkButton(box, text="OEE y Registro de Producci√≥n", height=48, corner_radius=14,
                      command=app.go_oee_select_machine).pack(pady=(0,12), ipadx=20)
        ctk.CTkButton(box, text="Recetas (Moldes/Partes)", height=44, corner_radius=14,
                      fg_color="#E5E7EB", text_color="#111", hover_color="#D1D5DB",
                      command=app.go_recipes).pack(pady=(0,8), ipadx=20)
        ctk.CTkButton(box, text="Planificaci√≥n + Milestones", height=44, corner_radius=14,
                      command=app.go_planning).pack(pady=(0,8), ipadx=20)
        ctk.CTkButton(box, text="Tablero de √ìrdenes (Progreso)", height=44, corner_radius=14,
                      command=app.go_orders_board).pack(pady=(0,8), ipadx=20)
        ctk.CTkButton(box, text="Salida de Piezas (Embarques)", height=44, corner_radius=14,
                      command=app.go_shipments).pack(pady=(0,8), ipadx=20)
        # === NUEVO:
        ctk.CTkButton(box, text="Reportes (KPIs & Gr√°ficas)", height=44, corner_radius=14,
                      command=app.go_reports).pack(pady=(0,8), ipadx=20)

# ---------- App ----------
class App(ctk.CTk):
    def __init__(self):
        super().__init__()
        ctk.set_appearance_mode("light"); ctk.set_default_color_theme("blue")
        self.title("Mefrup ‚Äî ALS")
        try: self.state("zoomed")
        except: self.geometry(f"{self.winfo_screenwidth()}x{self.winfo_screenheight()}")
        self._error_showing=False; self._update_job=None; self._last_tick_value=None; self._clock_label=None
        # estado OEE
        self.operador=tk.StringVar(value=""); self.turno=tk.IntVar(value=0)
        self.molde=tk.StringVar(value="")  # <<< string para no romper IDs de molde
        self.parte=tk.StringVar(value=""); self.ciclo_s=tk.IntVar(value=0)
        self.total=tk.StringVar(value="0"); self.scrap=tk.StringVar(value="0")
        self.fecha_sel=tk.StringVar(value=date.today().isoformat())
        # cron√≥metro paros
        self.paro_running=False; self.paro_accum_secs=0; self.paro_start_ts=None
        self.paro_motivo=""; self.paro_nota=""
        # m√©tricas / labels
        self.avail_rt=tk.StringVar(value="0.00%"); self.perf_rt=tk.StringVar(value="0.00%")
        self.qual_rt=tk.StringVar(value="0.00%"); self.oee_rt=tk.StringVar(value="0.00%")
        self.tot_day=tk.StringVar(value="0"); self.scr_day=tk.StringVar(value="0"); self.buen_day=tk.StringVar(value="0")
        self.perf_day=tk.StringVar(value="0.00%"); self.qual_day=tk.StringVar(value="0.00%"); self.oee_day=tk.StringVar(value="0.00%")
        self.day_info=tk.StringVar(value="Sin registros para la fecha."); self.oee_hist=tk.StringVar(value="0.00%")
        self.glob_total=tk.StringVar(value="0"); self.glob_scrap=tk.StringVar(value="0"); self.glob_buenas=tk.StringVar(value="0")
        self.glob_perf=tk.StringVar(value="0.00%"); self.glob_qual=tk.StringVar(value="0.00%"); self.glob_oee=tk.StringVar(value="0.00%")
        self.glob_info=tk.StringVar(value="Registros: 0 | D√≠as: 0")
        # recetas catalog
        asegurar_archivos_basicos(); self.recipes = leer_csv_dict(RECIPES_CSV); self.recipe_map = {}
        # vistas / contexto
        self.active_machine = None; self.oee_page = None; self.choose_page = None; self.oee_pages = {}
        self.machine_context = {}; self.dashboard_page = None
        # planificaci√≥n
        self.planning_page = None; self.orders_board_page = None; self.shipments_page = None; self.reports_page = None
        self._shipments_preselect_order = None
        # recalculo en tiempo real
        self.turno.trace_add("write", lambda *a: self._schedule_update())
        self.molde.trace_add("write", lambda *a: self._on_molde_change())
        self.total.trace_add("write", lambda *a: self._soft_sanitize(self.total, schedule=True))
        self.scrap.trace_add("write", lambda *a: self._soft_sanitize(self.scrap, schedule=True))
        # contenedor & vistas
        self.container=ctk.CTkFrame(self, corner_radius=0, fg_color="transparent"); self.container.pack(fill="both", expand=True)
        self.menu_page=MainMenu(self.container, self)
        self.recipes_page=RecipesView(self.container, self)
        self.choose_page=MachineChooser(self.container, self)
        self.dashboard_page=LiveDashboard(self.container, self)
        self._refresh_moldes_from_recipes(); self.go_menu()
        self.after(TICK_MS, self._tick); self.after(200, self._apply_initial_scale)
    def _set_text_if_changed(self, widget, text: str):
        if getattr(widget, "_last_text", None) != text:
            widget.configure(text=text); widget._last_text = text
    def _set_pb_if_changed(self, pb, frac: float, eps: float = 1e-3):
        frac = max(0.0, min(1.0, float(frac)))
        if abs(getattr(pb, "_last_val", -1.0) - frac) > eps:
            pb.set(frac); pb._last_val = frac
    # navegaci√≥n
    def _pack_only(self, view):
        for w in self.container.winfo_children(): w.pack_forget()
        view.pack(fill="both", expand=True)
    def go_menu(self):
        self._unbind_shortcuts_oee()
        self._pack_only(self.menu_page)

    def go_dashboard(self):
        self._unbind_shortcuts_oee()
        self._pack_only(self.dashboard_page)

    def go_oee_select_machine(self):
        self._unbind_shortcuts_oee()
        self._pack_only(self.choose_page)

    def go_oee(self, machine):
        self.active_machine = machine
        asegurar_archivos_maquina(machine)
        if machine["id"] not in self.oee_pages:
            self.oee_pages[machine["id"]] = OEEView(self.container, self, machine)
        self.oee_page = self.oee_pages[machine["id"]]
        self._refresh_moldes_from_recipes(force_update_menu=True)
        self._pack_only(self.oee_page)
        self._bind_shortcuts_oee()
        self._update_now(); self._refrescar_dia(); self._refrescar_hist(); self._refrescar_global()
        self._update_save_state(); self._refresh_paro_labels(); self._reload_downtime_table()

    def go_recipes(self):
        self._unbind_shortcuts_oee()
        self._pack_only(self.recipes_page)

    def go_planning(self):
        try:
            if not self.planning_page:
                self.planning_page = PlanningMilestonesView(self.container, self)  # definida m√°s abajo si ya la tienes
            self._pack_only(self.planning_page)
        except NameError:
            messagebox.showinfo("Planificaci√≥n", "La vista de Planificaci√≥n se carga m√°s abajo en el archivo.")

    def go_orders_board(self):
        try:
            if not self.orders_board_page:
                self.orders_board_page = OrdersBoardView(self.container, self)
            self._pack_only(self.orders_board_page)
        except NameError:
            messagebox.showinfo("√ìrdenes", "La vista de √ìrdenes se carga m√°s abajo en el archivo.")

    def go_shipments(self, preselect_order=None):
        self._shipments_preselect_order = preselect_order
        try:
            if not self.shipments_page:
                self.shipments_page = ShipmentsView(self.container, self)
            self._pack_only(self.shipments_page)
            if preselect_order and hasattr(self.shipments_page, "set_order"):
                self.shipments_page.set_order(preselect_order)
        except NameError:
            messagebox.showinfo("Embarques", "La vista de Salidas se carga m√°s abajo en el archivo.")

    def go_reports(self):
        try:
            if not self.reports_page:
                self.reports_page = ReportsView(self.container, self)
            self._pack_only(self.reports_page)
        except NameError:
            messagebox.showinfo("Reportes", "La vista de Reportes se carga m√°s abajo en el archivo.")

    # ======== atajos ========
    def _bind_shortcuts_oee(self):
        self.unbind("<Control-Return>"); self.bind("<Control-Return>", lambda e: self._guardar())
        self.unbind("<Control-g>"); self.bind("<Control-g>", lambda e: self._nudge(self.total,+1))
        self.unbind("<Control-h>"); self.bind("<Control-h>", lambda e: self._nudge(self.total,-1))
        self.unbind("<Control-s>"); self.bind("<Control-s>", lambda e: self._nudge(self.scrap,+1))
        self.unbind("<Control-d>"); self.bind("<Control-d>", lambda e: self._nudge(self.scrap,-1))

    def _unbind_shortcuts_oee(self):
        self.unbind("<Control-Return>"); self.unbind("<Control-g>"); self.unbind("<Control-h>")
        self.unbind("<Control-s>"); self.unbind("<Control-d>")

    # ======== manejo de errores ========
    def report_callback_exception(self, exc, val, tb):
        try:
            logging.basicConfig(filename=os.path.join(BASE_DIR,"ui_errors.log"),
                                level=logging.ERROR,filemode="a")
            logging.error("".join(traceback.format_exception(exc,val,tb)))
        except:
            pass
        if getattr(self,"_error_showing",False): return
        self._error_showing=True
        try:
            messagebox.showerror("Error en la UI", f"{val}\n(Detalle en ui_errors.log)")
        finally:
            self.after(200, lambda: setattr(self,"_error_showing",False))

    # ======== setters desde UI ========
    def _set_operador(self, nombre:str):
        self.operador.set(nombre or ""); self._update_save_state()

    def _set_turno(self, turno_val):
        try: self.turno.set(int(turno_val))
        except: self.turno.set(0)
        self._update_now(); self._update_save_state()

    def _set_molde(self, molde_val):
        v = (molde_val or "").strip()
        self.molde.set(v)
        try:
            if hasattr(self, "molde_menu"):
                vals = self.molde_menu.cget("values")
                if v in vals: self.molde_menu.set(v)
        except: pass
        self._update_save_state()

    # ======== recetas / moldes ========
    def _refresh_moldes_from_recipes(self, force_update_menu=False):
        self.recipes = leer_csv_dict(RECIPES_CSV)
        self.recipe_map = {}
        opciones = ["Selecciona"]
        for r in self.recipes:
            if r.get("activo","1") == "1":
                mid = (r.get("molde_id") or "").strip()
                if mid:
                    self.recipe_map[mid] = r
                    opciones.append(mid)
        if hasattr(self, "molde_menu"):
            try:
                self.molde_menu.configure(values=opciones)
                cur = (self.molde.get() or "")
                if cur not in opciones:
                    self.molde.set(""); self.ciclo_s.set(0); self.parte.set("")
                if force_update_menu and cur in opciones:
                    self.molde_menu.set(cur if cur else "Selecciona")
            except: pass
        if force_update_menu and self.oee_page:
            try: self._on_molde_change()
            except: pass

    def _on_molde_change(self, *_):
        mid = (self.molde.get() or "").strip()
        rec = self.recipe_map.get(mid)
        if rec:
            self.parte.set((rec.get("parte") or "").strip())
            raw=(rec.get("ciclo_ideal_s") or "").replace(",",".").strip()
            try: self.ciclo_s.set(int(float(raw)))
            except: self.ciclo_s.set(0)
            self.rec_cavs=(rec.get("cavidades") or "").strip()
            self.rec_cavs_on=(rec.get("cavidades_habilitadas") or "").strip()
            self.rec_scrap=(rec.get("scrap_esperado_pct") or "").strip()
        else:
            self.parte.set(""); self.ciclo_s.set(0)
            self.rec_cavs=self.rec_cavs_on=self.rec_scrap=""
        if hasattr(self,"lbl_parte"):
            try: self.lbl_parte.configure(text=self.parte.get() or "-")
            except: pass
        if hasattr(self,"lbl_cavs"):
            try:
                cavs_on=getattr(self,"rec_cavs_on","") or "-"
                cavs=getattr(self,"rec_cavs","") or "-"
                self.lbl_cavs.configure(text=f"{cavs_on}/{cavs}")
            except: pass
        self._schedule_update()

    # ======== entrada / sanitizado ========
    def _get_int(self, v:tk.StringVar):
        s=(v.get() or "").strip()
        if s.startswith("-"): s=s[1:]
        return int(s) if s.isdigit() else 0

    def _set_int(self, v:tk.StringVar, n:int):
        v.set(str(max(0,int(n))))

    def _sanitize(self, v:tk.StringVar):
        self._set_int(v, self._get_int(v)); self._update_now()

    def _nudge(self, v:tk.StringVar, d:int):
        self._set_int(v, self._get_int(v)+d); self._update_now()

    def _soft_sanitize(self, var: tk.StringVar, schedule=False):
        s=(var.get() or "")
        ns="".join(ch for ch in s if ch.isdigit())
        if ns!=s: var.set(ns)
        if var is self.scrap:
            try:
                t=int(self.total.get() or 0); sc=int(self.scrap.get() or 0)
                if sc>t: self.scrap.set(str(t))
            except: pass
        if schedule: self._schedule_update()

    # ======== debounce ========
    def _schedule_update(self):
        if self._update_job: self.after_cancel(self._update_job)
        self._update_job = self.after(DEBOUNCE_MS, self._update_now)

    def _update_now(self):
        self._update_job=None
        self._update_calculos()

    # ======== fecha ========
    def _on_fecha_change(self):
        f=self.fecha_sel.get().strip()
        try: y,m,d=map(int,f.split("-")); _=date(y,m,d)
        except:
            messagebox.showwarning("Fecha inv√°lida","Usa YYYY-MM-DD."); return
        if self.oee_page and hasattr(self.oee_page,"lbl_dia"):
            self.oee_page.lbl_dia.configure(text=f"{dia_semana_es(f)} ‚Äî {f}")
        self._refrescar_dia(); self._update_save_state(); self._reload_downtime_table()

    def _open_calendar(self):
        try:
            y,m,d=map(int,(self.fecha_sel.get() or date.today().isoformat()).split("-"))
            init=date(y,m,d)
        except:
            init=date.today()
        top=tk.Toplevel(self); top.title("Selecciona fecha"); top.transient(self); top.grab_set(); top.resizable(False,False)
        self.update_idletasks()
        top.geometry(f"+{self.winfo_rootx()+self.winfo_width()//2-180}+{self.winfo_rooty()+self.winfo_height()//2-170}")
        cal=Calendar(top, selectmode="day", year=init.year, month=init.month, day=init.day, date_pattern="yyyy-mm-dd",
                     firstweekday="monday", showweeknumbers=False)
        cal.pack(padx=14, pady=14)
        b=tk.Frame(top); b.pack(fill="x", padx=14, pady=(0,14))
        def choose():
            ch=cal.get_date()
            self.fecha_sel.set(ch); self._on_fecha_change(); top.destroy()
        tk.Button(b, text="Seleccionar", command=choose).pack(side="left", padx=(0,6))
        tk.Button(b, text="Cerrar", command=top.destroy).pack(side="left")

    # ======== paros / cron√≥metro ========
    def toggle_paro(self):
        if not self.active_machine:
            messagebox.showwarning("M√°quina","Primero elige una m√°quina."); return
        if not self.paro_running:
            motivo = getattr(self, "motivo_menu", None).get() if hasattr(self, "motivo_menu") else MOTIVOS_PARO[0]
            nota   = getattr(self, "nota_entry", None).get() if hasattr(self, "nota_entry") else ""
            self.paro_motivo=motivo; self.paro_nota=nota
            self.paro_running=True; self.paro_start_ts=datetime.now()
            self.btn_toggle_paro.configure(text="Reanudar", fg_color="#10b981", hover_color="#059669")
        else:
            self._finalizar_evento_paro()
            self.paro_running=False; self.paro_start_ts=None
            self.paro_motivo=""; self.paro_nota=""
            self.btn_toggle_paro.configure(text="Iniciar paro", fg_color="#ef4444", hover_color="#dc2626")
        self._refresh_paro_labels(); self._schedule_update(); self._update_save_state()

    def _finalizar_evento_paro(self):
        if not (self.paro_start_ts and self.active_machine): return
        dur=int((datetime.now()-self.paro_start_ts).total_seconds())
        self.paro_accum_secs += max(0,dur)
        row=[self.fecha_sel.get().strip(),
             self.paro_start_ts.strftime("%Y-%m-%d %H:%M:%S"),
             datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
             str(dur), self.paro_motivo, self.paro_nota,
             self.operador.get(), str(self.turno.get() or ""), self.molde.get() or ""]
        try:
            with open(self.active_machine["down_csv"],"a",newline="",encoding="utf-8") as f:
                csv.writer(f).writerow(row)
        except PermissionError:
            messagebox.showerror("Archivo en uso","Cierra el CSV de paros.")
        self._reload_downtime_table()

    def reset_paros(self):
        if self.paro_running:
            messagebox.showwarning("Paro activo","Det√©n el paro antes de reiniciar."); return
        if messagebox.askyesno("Reset de paros","¬øReiniciar a 00:00:00 el paro acumulado del turno?"):
            self.paro_accum_secs=0; self._refresh_paro_labels(); self._schedule_update()

    def _current_paro_secs(self):
        return int((datetime.now()-self.paro_start_ts).total_seconds()) if (self.paro_running and self.paro_start_ts) else 0

    def _total_paro_secs(self):
        return self.paro_accum_secs + self._current_paro_secs()

    def _refresh_paro_labels(self):
        if hasattr(self,"lbl_paro_actual"): self.lbl_paro_actual.configure(text=segs_to_hms_str(self._current_paro_secs()))
        if hasattr(self,"lbl_paro_acum"):   self.lbl_paro_acum.configure(text=segs_to_hms_str(self._total_paro_secs()))

    def _tick(self):
        if self._clock_label:
            self._clock_label.configure(text=datetime.now().strftime("%d/%m/%Y %H:%M:%S"))
        now_val = self._current_paro_secs() if self.paro_running else None
        if now_val is not None and now_val != self._last_tick_value:
            self._last_tick_value = now_val
            self._refresh_paro_labels()
            self._schedule_update()
        self.after(TICK_MS, self._tick)

    def _reload_downtime_table(self):
        if not (hasattr(self, "tree") and self.active_machine): return
        for i in self.tree.get_children(): self.tree.delete(i)
        f=self.fecha_sel.get().strip()
        for r in leer_csv_dict(self.active_machine["down_csv"]):
            if r.get("fecha")!=f: continue
            try: dmin = round(int(float(r.get("duracion_seg","0")))/60.0,1)
            except: dmin=0.0
            self.tree.insert("", "end", values=(r.get("inicio_ts",""), r.get("fin_ts",""),
                                                r.get("motivo",""), r.get("nota",""), f"{dmin:.1f}"))

    # ======== c√°lculos + guardar ========
    def _update_calculos(self):
        horas = TURNOS_HORAS.get(int(self.turno.get() or 0), 0)
        ciclo = int(self.ciclo_s.get() or 0)
        turno_seg, oper_seg, meta_plan, meta_oper = calcular_tiempos(horas, ciclo, self._total_paro_secs())
        if hasattr(self,"meta_plan_val"): self._set_text_if_changed(self.meta_plan_val, str(meta_plan))
        if hasattr(self,"meta_oper_val"): self._set_text_if_changed(self.meta_oper_val, str(meta_oper))

        total=self._get_int(self.total); scrap=min(self._get_int(self.scrap), total)
        buenas, A, P, Q, OEE = calcular_metricas(total, scrap, turno_seg, oper_seg, ciclo)
        self.avail_rt.set(f"{A:.2f}%"); self.perf_rt.set(f"{P:.2f}%")
        self.qual_rt.set(f"{Q:.2f}%");  self.oee_rt.set(f"{OEE:.2f}%")
        if hasattr(self,"pb_avail"):   self._set_pb_if_changed(self.pb_avail, A/100.0)
        if hasattr(self,"pb_meta"):    self._set_pb_if_changed(self.pb_meta,  (total/meta_oper) if meta_oper>0 else 0.0)
        if hasattr(self,"pb_quality"): self._set_pb_if_changed(self.pb_quality, (buenas/total) if total>0 else 0.0)

    def _turno_bloqueado_maquina(self, machine, fecha_iso, turno:int) -> bool:
        rows = leer_csv_dict(machine["oee_csv"])
        for r in rows:
            try:
                if r.get("fecha")==fecha_iso and int(float(r.get("turno","0")))==int(turno):
                    return True
            except: pass
        return False

    def _guardar(self):
        if not self.active_machine:
            messagebox.showwarning("M√°quina","Primero elige una m√°quina."); return
        f=self.fecha_sel.get().strip()
        if self.paro_running:
            messagebox.showwarning("Paro activo","Det√©n el paro antes de guardar."); return
        if not (self.operador.get() and self.turno.get() and self.molde.get()):
            messagebox.showwarning("Faltan datos","Selecciona operador, turno y molde."); return
        try: y,m,d=map(int,f.split("-")); _=date(y,m,d)
        except:
            messagebox.showwarning("Fecha inv√°lida","Usa YYYY-MM-DD."); return
        if self._turno_bloqueado_maquina(self.active_machine, f, int(self.turno.get())):
            messagebox.showwarning("Turno ya registrado", f"{f} ‚Äî turno {self.turno.get()} ya fue registrado en {self.active_machine['name']}."); 
            return

        total=self._get_int(self.total); scrap=min(self._get_int(self.scrap), total)
        paro_seg=self._total_paro_secs()
        horas=TURNOS_HORAS.get(int(self.turno.get() or 0),0); ciclo=int(self.ciclo_s.get() or 0)
        turno_seg, oper_seg, _, meta_oper = calcular_tiempos(horas, ciclo, paro_seg)
        buenas, A, P, Q, OEE = calcular_metricas(total, scrap, turno_seg, oper_seg, ciclo)

        ts=f"{f}T{datetime.now().strftime('%H:%M:%S')}"
        row=[ts,f,self.operador.get(),self.turno.get(),self.molde.get(),self.parte.get(),ciclo,horas,
             int(round(paro_seg/60.0)), meta_oper,total,scrap,buenas,A,P,Q,OEE]
        try:
            with open(self.active_machine["oee_csv"],"a",newline="",encoding="utf-8") as fi:
                csv.writer(fi).writerow(row)
        except PermissionError:
            messagebox.showerror("Archivo en uso","Cierra el CSV de la m√°quina y vuelve a intentar."); return

        rows_maquina = leer_csv_dict(self.active_machine["oee_csv"])
        a=acum_por_fecha(rows_maquina, f)
        escribir_daily(DAILY_CSV_GLOBAL, f, a["oee_pct"], a["total"], a["scrap"], a["meta_pzs"])

        # actualizado: OEE del √°rea = promedio del OEE d√≠a de cada m√°quina
        oees=[]
        for m in MACHINES:
            r = acum_por_fecha(leer_csv_dict(m["oee_csv"]), f)
            if r["total"]>0 and r["meta_pzs"]>0:
                oees.append(r["oee_pct"])
        OEE_area = (sum(oees)/len(oees)) if oees else 0.0
        total_area = sum(acum_por_fecha(leer_csv_dict(m["oee_csv"]), f)["total"] for m in MACHINES)
        scrap_area = sum(acum_por_fecha(leer_csv_dict(m["oee_csv"]), f)["scrap"] for m in MACHINES)
        meta_area  = sum(acum_por_fecha(leer_csv_dict(m["oee_csv"]), f)["meta_pzs"] for m in MACHINES)
        escribir_daily(DAILY_CSV_INJECTOR, f, OEE_area, total_area, scrap_area, meta_area)

        self._refrescar_dia(); self._refrescar_hist(); self._refrescar_global(); self._update_save_state()
        messagebox.showinfo("Guardado",
                            f"M√°quina: {self.active_machine['name']}\n"
                            f"OEE {OEE:.2f}% (A {A:.2f}% | P {P:.2f}% | Q {Q:.2f}%)")

    def _refrescar_dia(self):
        if not self.active_machine: return
        f=self.fecha_sel.get().strip()
        if self.oee_page and hasattr(self.oee_page,"lbl_dia"):
            self.oee_page.lbl_dia.configure(text=f"{dia_semana_es(f)} ‚Äî {f}")
        a=acum_por_fecha(leer_csv_dict(self.active_machine["oee_csv"]), f)
        self.tot_day.set(str(a["total"])); self.scr_day.set(str(a["scrap"])); self.buen_day.set(str(a["buenas"]))
        self.perf_day.set(f"{a['perf_pct']:.2f}%"); self.qual_day.set(f"{a['qual_pct']:.2f}%"); self.oee_day.set(f"{a['oee_pct']:.2f}%")
        self.day_info.set("Registros del d√≠a: "+str(a.get("count",0)) if a.get("count",0) else "Sin registros para la fecha.")

    def _refrescar_hist(self):
        self.oee_hist.set(f"{promedio_oee_daily(DAILY_CSV_GLOBAL):.2f}%")

    def _refrescar_global(self):
        if not self.active_machine: return
        g=acum_global(leer_csv_dict(self.active_machine["oee_csv"]))
        self.glob_total.set(str(g["total"])); self.glob_scrap.set(str(g["scrap"])); self.glob_buenas.set(str(g["buenas"]))
        self.glob_perf.set(f"{g['perf_pct']:.2f}%"); self.glob_qual.set(f"{g['qual_pct']:.2f}%"); self.glob_oee.set(f"{g['oee_pct']:.2f}%")
        self.glob_info.set(f"Registros: {g['registros']} | D√≠as: {g['dias']}")

    def _reset_contadores(self):
        if self.paro_running:
            messagebox.showwarning("Paro activo","Det√©n el paro antes de resetear."); return
        self.total.set("0"); self.scrap.set("0"); self.paro_accum_secs=0
        self._refresh_paro_labels(); self._update_now()

    def _update_save_state(self):
        ready = bool(self.operador.get()) and bool(self.turno.get()) and bool(self.molde.get()) and self.active_machine
        if self.paro_running: ready=False
        try: self.btn_guardar.configure(state=("normal" if ready else "disabled"))
        except: pass

    def _apply_initial_scale(self):
        try:
            s=min(max(self.winfo_screenwidth()/1920.0, 0.95), 1.20)
            ctk.set_widget_scaling(s)
        except: pass
class ReportsView(ctk.CTkFrame):
    """Reportes por m√°quina y rango (KPIs + gr√°ficas)."""
    def __init__(self, master, app):
        super().__init__(master, fg_color="transparent")
        self.app = app
        self._build()

    # ---- utilidades UI ----
    def _calendar_pick(self, entry: ctk.CTkEntry):
        try:
            y,m,d=map(int,(entry.get() or date.today().isoformat()).split("-")); init=date(y,m,d)
        except: init=date.today()
        top=tk.Toplevel(self); top.title("Selecciona fecha"); top.transient(self); top.grab_set(); top.resizable(False,False)
        self.update_idletasks()
        top.geometry(f"+{self.winfo_rootx()+self.winfo_width()//2-180}+{self.winfo_rooty()+self.winfo_height()//2-170}")
        cal=Calendar(top, selectmode="day", year=init.year, month=init.month, day=init.day, date_pattern="yyyy-mm-dd",
                     firstweekday="monday", showweeknumbers=False)
        cal.pack(padx=14, pady=14)
        def choose():
            entry.delete(0,"end"); entry.insert(0, cal.get_date()); top.destroy()
        tk.Button(top, text="Seleccionar", command=choose).pack(side="left", padx=10, pady=10)
        tk.Button(top, text="Cerrar", command=top.destroy).pack(side="left", padx=10, pady=10)

    def _build(self):
        header=ctk.CTkFrame(self, corner_radius=0, fg_color=("white","#111111"))
        header.pack(fill="x", side="top")
        left=ctk.CTkFrame(header, fg_color="transparent"); left.pack(side="left", padx=16, pady=10)
        ctk.CTkButton(left, text="‚Üê Men√∫", command=self.app.go_menu, width=110, corner_radius=10,
                      fg_color="#E5E7EB", text_color="#111", hover_color="#D1D5DB").pack(side="left", padx=(0,10))
        ctk.CTkLabel(left, text="Reportes ‚Äî KPIs y Gr√°ficas",
                     font=ctk.CTkFont("Helvetica",20,"bold")).pack(side="left")

        body=ctk.CTkFrame(self, fg_color="transparent"); body.pack(fill="both", expand=True, padx=16, pady=16)

        # Filtros
        filters=ctk.CTkFrame(body, corner_radius=16); filters.pack(fill="x", padx=0, pady=(0,12))
        ctk.CTkLabel(filters, text="Filtros", font=ctk.CTkFont("Helvetica", 14, "bold")).pack(anchor="w", padx=12, pady=(10,6))
        ctk.CTkFrame(filters, height=1, fg_color=("#E5E7EB","#2B2B2B")).pack(fill="x", padx=12, pady=(0,10))
        row=ctk.CTkFrame(filters, fg_color="transparent"); row.pack(fill="x", padx=12, pady=4)
        self.om_machine = ctk.CTkOptionMenu(row, values=[m["id"] for m in MACHINES], width=160)
        self.om_machine.set(MACHINES[0]["id"]); self.om_machine.pack(side="left", padx=(0,8))
        self.e_from = ctk.CTkEntry(row, placeholder_text="Desde (YYYY-MM-DD)", width=160); self.e_from.pack(side="left", padx=(8,6))
        ctk.CTkButton(row, text="üìÖ", width=36, command=lambda:self._calendar_pick(self.e_from)).pack(side="left")
        self.e_to   = ctk.CTkEntry(row, placeholder_text="Hasta (YYYY-MM-DD)", width=160); self.e_to.pack(side="left", padx=(12,6))
        ctk.CTkButton(row, text="üìÖ", width=36, command=lambda:self._calendar_pick(self.e_to)).pack(side="left", padx=(0,8))
        ctk.CTkButton(row, text="Generar", command=self._run_report).pack(side="left", padx=8)
        ctk.CTkButton(row, text="Exportar CSV", fg_color="#E5E7EB", text_color="#111", hover_color="#D1D5DB",
                      command=self._export_csv).pack(side="left", padx=8)

        # Tarjetas KPI
        self.kpis_wrap = ctk.CTkFrame(body, corner_radius=16); self.kpis_wrap.pack(fill="x", padx=0, pady=(0,12))
        ctk.CTkLabel(self.kpis_wrap, text="KPIs", font=ctk.CTkFont("Helvetica", 14, "bold"))\
            .pack(anchor="w", padx=12, pady=(10,0))
        self.kpi_cards = ctk.CTkFrame(self.kpis_wrap, fg_color="transparent"); self.kpi_cards.pack(fill="x", padx=12, pady=(8,12))

        # Charts
        self.charts = ctk.CTkScrollableFrame(self, corner_radius=0)
        self.charts.pack(fill="both", expand=True, padx=16, pady=(0,16))

        # Default: hoy
        today=date.today().isoformat()
        self.e_from.insert(0, today); self.e_to.insert(0, today)
        self._run_report()

    # ---- c√°lculos ----
    def _rows_in_range(self, csv_path, start, end):
        out=[]
        for r in leer_csv_dict(csv_path):
            f=r.get("fecha","")
            if not f: continue
            if start and f < start: continue
            if end and f > end: continue
            out.append(r)
        return out

    def _agg(self, rows):
        turno_seg = 0; paro_seg=0; perf_num=0.0; total=0; scrap=0
        for r in rows:
            try: horas=float(str(r.get("horas_turno","0")).replace(",",".")) or 0.0
            except: horas=0.0
            turno_seg += int(horas*3600)
            try: pmin=float(str(r.get("tiempo_paro_min","0")).replace(",",".")) or 0.0
            except: pmin=0.0
            paro_seg += int(pmin*60)
            ciclo = parse_int_str(r.get("ciclo_s","0"),0)
            buenas= parse_int_str(r.get("buenas_pzs","0"),0)
            total += parse_int_str(r.get("total_pzs","0"),0)
            scrap += parse_int_str(r.get("scrap_pzs","0"),0)
            if ciclo>0 and buenas>0:
                perf_num += buenas * ciclo
        oper_seg=max(0, turno_seg - paro_seg)
        A=(oper_seg/turno_seg) if turno_seg>0 else 0.0
        P=(perf_num/oper_seg)  if oper_seg>0 else 0.0
        Q=((total-scrap)/total) if total>0 else 0.0
        O=A*P*Q
        return {
            "turno_seg":turno_seg,"oper_seg":oper_seg,"paro_seg":paro_seg,
            "total":total,"buenas":max(0,total-scrap),"scrap":scrap,
            "A":round(A*100,2),"P":round(P*100,2),"Q":round(Q*100,2),"OEE":round(O*100,2)
        }

    # ---- UI helpers ----
    def _kpi_card(self, parent, title, value, subtitle=None, bg=("#F3F4F6","#1F2937")):
        card = ctk.CTkFrame(parent, corner_radius=14)
        card.pack(side="left", fill="x", expand=True, padx=6)
        ctk.CTkLabel(card, text=title, font=ctk.CTkFont("Helvetica",12)).pack(anchor="w", padx=10, pady=(8,0))
        ctk.CTkLabel(card, text=value, font=ctk.CTkFont("Helvetica",22,"bold")).pack(anchor="w", padx=10, pady=(0,6))
        if subtitle:
            ctk.CTkLabel(card, text=subtitle, text_color=("#6b7280","#9CA3AF")).pack(anchor="w", padx=10, pady=(0,8))
        return card

    def _run_report(self):
        # limpia charts
        for w in self.charts.winfo_children(): w.destroy()
        for w in self.kpi_cards.winfo_children(): w.destroy()

        mid = self.om_machine.get().strip()
        start=self.e_from.get().strip() or None
        end  =self.e_to.get().strip()   or None
        m = next((mm for mm in MACHINES if mm["id"]==mid), MACHINES[0])

        rows = self._rows_in_range(m["oee_csv"], start, end)
        agg  = self._agg(rows)

        # Tarjetas KPI
        self._kpi_card(self.kpi_cards, "Availability", f"{agg['A']:.2f}%")
        self._kpi_card(self.kpi_cards, "Effectivity (P)", f"{agg['P']:.2f}%")
        self._kpi_card(self.kpi_cards, "Quality", f"{agg['Q']:.2f}%")
        self._kpi_card(self.kpi_cards, "OEE", f"{agg['OEE']:.2f}%")
        self._kpi_card(self.kpi_cards, "Buenas", f"{agg['buenas']}")
        self._kpi_card(self.kpi_cards, "Scrap",  f"{agg['scrap']}")
        self._kpi_card(self.kpi_cards, "Total",  f"{agg['total']}")
        def hhmm(secs): secs=max(0,int(secs)); h=secs//3600; mi=(secs%3600)//60; return f"{h:02d}:{mi:02d} h:mm"
        self._kpi_card(self.kpi_cards, "Nom. production time", hhmm(agg["oper_seg"]))
        self._kpi_card(self.kpi_cards, "Total standstills", hhmm(agg["paro_seg"]))

        sns.set_theme(style="whitegrid")

        # KPI barras con labels
        kframe = ctk.CTkFrame(self.charts, corner_radius=16); kframe.pack(fill="x", padx=8, pady=8)
        ctk.CTkLabel(kframe, text=f"KPI ‚Äî {m['name']}", font=ctk.CTkFont("Helvetica", 13, "bold"))\
            .pack(anchor="w", padx=8, pady=(8,0))
        fig, ax = plt.subplots(figsize=(7.5,2.6), dpi=120)
        dfk = pd.DataFrame({"KPI":["Availability","Effectivity","Quality","OEE"],
                            "Valor":[agg["A"], agg["P"], agg["Q"], agg["OEE"]]})
        sns.barplot(ax=ax, data=dfk, x="KPI", y="Valor")
        ax.set_ylim(0,100); ax.set_ylabel("%"); ax.grid(True, axis="y", alpha=0.25)
        for p, v in zip(ax.patches, dfk["Valor"]):
            ax.annotate(f"{v:.1f}%", (p.get_x()+p.get_width()/2, p.get_height()),
                        ha="center", va="bottom", fontsize=9, xytext=(0,3), textcoords="offset points")
        canvas=FigureCanvasTkAgg(fig, master=kframe); canvas.draw(); canvas.get_tk_widget().pack(fill="x", padx=8, pady=8); plt.close(fig)

        # OEE por d√≠a (l√≠nea con relleno)
        if rows:
            # agrupaci√≥n segura por fecha
            sums={}
            for r in rows:
                f=r.get("fecha",""); 
                if not f: continue
                if f not in sums: sums[f]=[]
                sums[f].append(r)
            byday=[]
            for f, rr in sorted(sums.items()):
                a=acum_por_fecha(rr, f); byday.append((f, a["oee_pct"]))
            if byday:
                lframe = ctk.CTkFrame(self.charts, corner_radius=16); lframe.pack(fill="x", padx=8, pady=8)
                ctk.CTkLabel(lframe, text="OEE por d√≠a", font=ctk.CTkFont("Helvetica", 13, "bold"))\
                    .pack(anchor="w", padx=8, pady=(8,0))
                dfl = pd.DataFrame(byday, columns=["fecha","OEE"])
                fig2, ax2 = plt.subplots(figsize=(7.5,2.6), dpi=120)
                sns.lineplot(ax=ax2, data=dfl, x="fecha", y="OEE", marker="o")
                ax2.fill_between(dfl["fecha"], dfl["OEE"], 0, alpha=0.15)
                for x, y in zip(dfl["fecha"], dfl["OEE"]):
                    ax2.text(x, y+2, f"{y:.0f}%", ha="center", va="bottom", fontsize=8)
                ax2.set_ylim(0,100); ax2.grid(True, alpha=0.25); ax2.set_xlabel(""); ax2.set_ylabel("%")
                canvas2=FigureCanvasTkAgg(fig2, master=lframe); canvas2.draw(); canvas2.get_tk_widget().pack(fill="x", padx=8, pady=8); plt.close(fig2)

        # Buenas vs Scrap (barras apiladas por total)
        bframe = ctk.CTkFrame(self.charts, corner_radius=16); bframe.pack(fill="x", padx=8, pady=8)
        ctk.CTkLabel(bframe, text="Buenas vs Scrap", font=ctk.CTkFont("Helvetica", 13, "bold"))\
            .pack(anchor="w", padx=8, pady=(8,0))
        figb, axb = plt.subplots(figsize=(7.5,2.2), dpi=120)
        total = max(1, agg["total"]); buenas = agg["buenas"]; scrap = agg["scrap"]
        axb.bar(["Piezas"], [buenas], label="Buenas")
        axb.bar(["Piezas"], [scrap], bottom=[buenas], label="Scrap")
        axb.set_ylim(0, total*1.15); axb.grid(True, axis="y", alpha=0.25); axb.legend()
        axb.annotate(f"{buenas} ({buenas/total*100:.1f}%)", (0, buenas), ha="center", va="bottom", fontsize=9, xytext=(0,3), textcoords="offset points")
        axb.annotate(f"{scrap} ({scrap/total*100:.1f}%)", (0, buenas+scrap), ha="center", va="bottom", fontsize=9, xytext=(0,3), textcoords="offset points")
        canvasb=FigureCanvasTkAgg(figb, master=bframe); canvasb.draw(); canvasb.get_tk_widget().pack(fill="x", padx=8, pady=8); plt.close(figb)

        # Causas de paro (Top ordenadas)
        downs = self._rows_in_range(m["down_csv"], start, end)
        causas={}
        for r in downs:
            mot=(r.get("motivo","") or "‚Äî").strip()
            try: mins = round(int(float(r.get("duracion_seg","0")))/60.0,1)
            except: mins = 0.0
            causas[mot]=causas.get(mot,0.0)+mins
        if causas:
            cframe = ctk.CTkFrame(self.charts, corner_radius=16); cframe.pack(fill="x", padx=8, pady=8)
            ctk.CTkLabel(cframe, text="Standstills por causa (min)", font=ctk.CTkFont("Helvetica", 13, "bold"))\
                .pack(anchor="w", padx=8, pady=(8,0))
            dfc = pd.DataFrame({"Causa": list(causas.keys()), "Minutos": list(causas.values())})\
                    .sort_values("Minutos", ascending=False)
            fig3, ax3 = plt.subplots(figsize=(7.5,2.8), dpi=120)
            sns.barplot(ax=ax3, data=dfc, x="Minutos", y="Causa", orient="h")
            for p, v in zip(ax3.patches, dfc["Minutos"]):
                ax3.annotate(f"{v:.1f}", (p.get_x()+p.get_width(), p.get_y()+p.get_height()/2),
                             ha="left", va="center", fontsize=9, xytext=(3,0), textcoords="offset points")
            ax3.grid(True, axis="x", alpha=0.25)
            canvas3=FigureCanvasTkAgg(fig3, master=cframe); canvas3.draw(); canvas3.get_tk_widget().pack(fill="x", padx=8, pady=8); plt.close(fig3)

    def _export_csv(self):
        mid = self.om_machine.get().strip()
        start=self.e_from.get().strip() or None
        end  =self.e_to.get().strip()   or None
        m = next((mm for mm in MACHINES if mm["id"]==mid), MACHINES[0])
        rows = self._rows_in_range(m["oee_csv"], start, end)
        if not rows:
            messagebox.showinfo("Exportar","No hay registros en el rango."); return
        out_path = os.path.join(BASE_DIR, f"reporte_{mid}_{start or 'ini'}_{end or 'fin'}.csv")
        cols=["timestamp","fecha","operador","turno","molde","parte","ciclo_s","horas_turno",
              "tiempo_paro_min","meta_oper_pzs","total_pzs","scrap_pzs","buenas_pzs",
              "availability_%","performance_%","quality_%","oee_%"]
        with open(out_path,"w",newline="",encoding="utf-8") as f:
            w=csv.DictWriter(f, fieldnames=cols); w.writeheader()
            for r in rows: w.writerow({k:r.get(k,"") for k in cols})
        messagebox.showinfo("Exportar", f"Reporte guardado:\n{out_path}")

    App().mainloop()
